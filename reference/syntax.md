# 语法

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [语法](#语法)
  - [IR 程序](#ir-程序)
  - [表达式](#表达式)
    - [结构表达式](#结构表达式)
    - [函数求值表达式](#函数求值表达式)
  - [IR 程序的源码结构](#ir-程序的源码结构)
    - [注释](#注释)
    - [标注](#标注)
  - [REPL 模式](#repl-模式)
  - [基本数据类型](#基本数据类型)
    - [`int` 数据类型](#int-数据类型)
    - [标识符的数据类型表示方法](#标识符的数据类型表示方法)
    - [字符串字面量](#字符串字面量)
    - [元组](#元组)
  - [标识符的操作符](#标识符的操作符)
  - [Namespace 表达式](#namespace-表达式)
    - [层次型命名空间](#层次型命名空间)
    - [根命名空间](#根命名空间)
    - [访问不同模块里的函数或只读数据](#访问不同模块里的函数或只读数据)
    - [访问同一个模块但不同命名空间里的函数或只读数据](#访问同一个模块但不同命名空间里的函数或只读数据)
    - [访问同一个命名空间里的函数或只读数据](#访问同一个命名空间里的函数或只读数据)
  - [Do 表达式](#do-表达式)
    - [作用域](#作用域)
      - [并列型作用域结构](#并列型作用域结构)
      - [层次型作用域结构](#层次型作用域结构)
      - [标识符名称冲突](#标识符名称冲突)
      - [拥有作用域的表达式](#拥有作用域的表达式)
  - [Data 表达式](#data-表达式)
    - [操作符 `#`](#操作符)
  - [Let 表达式](#let-表达式)
    - [值的不变性](#值的不变性)
    - [值的复制](#值的复制)
    - [元组的赋值](#元组的赋值)
  - [If 表达式](#if-表达式)
    - [嵌套 `If 表达式`](#嵌套-if-表达式)
    - [`If 表达式` 的作用域](#if-表达式-的作用域)
  - [Loop 表达式](#loop-表达式)
  - [Defn 表达式](#defn-表达式)
    - [元组返回值](#元组返回值)
    - [元组参数](#元组参数)
  - [Call 表达式](#call-表达式)
    - [操作符 `$`](#操作符-1)
    - [匿名函数的实现](#匿名函数的实现)
  - [Closure 表达式](#closure-表达式)
    - [操作符 `%`](#操作符-2)
    - [匿名函数的闭包的实现](#匿名函数的闭包的实现)
  - [Defnr 表达式](#defnr-表达式)

<!-- /code_chunk_output -->

XiaoXuan Lang IR （以下简称为 IR） 是 XiaoXuan Lang （或其他上层语言） 编译为目标程序（本地程序或者 WASM 字节码）过程中的中间代码，它是对常见的机器指令和常见的程序结构的简单抽象和封装。

IR 并不是直接面向用户（程序员）的编程语言，也不是 Lisp 语言的方言。但 IR 的设计非常简单，而且有一门完整语言的特性，所以可以实现 IR 的解析器（Interpreter）用于直接运行 IR 代码，这能简化对 Lang 的编译器前端的调试。

## IR 程序

一个 IR 程序（或者库）包含一个或多个 IR 源码文件，还有一个名为 "module.toml" 的项目描述文件，所有文件使用 `utf-8` 编码储存。

下面是一个 IR 程序的示例，程序打印出一行字符 "Hello World!" 以及计算 `斐波那契`（`Fibonacci`）第 8 个数的值。

文件 `app.xir` 的内容：

```clojure
(namespace app
    (data hello string "Hello World!")

    (defn fib (i)
        (if (eq i 1)
            1
            (if (eq i 2)
                2
                (do
                    (let a (sub i 1))
                    (let b (sub i 2))

                    (let m (fib a))
                    (let n (fib b))

                    (add m n)
                )
            )
        )
    )

    (defn main ()
        (do
            (puts #hello)
            (let i (fib 8))
            (print_i64 i)
        )
    )
)
```

文件 `module.toml` 的内容：

```toml
[module]
name = "example"
version = "0.1.0"
type = "app"
```

## 表达式

IR 源码采用 [`S-表达式`（`S-Expression`）](https://en.wikipedia.org/wiki/S-expression) 格式。

具体来说，IR 源码由一系列嵌套的 `表达式`（`Expression`）组成，每个 `表达式` 由一对圆括号，以及在圆括号里面的一个或多个由空格分开的 `符号`（`Symbol`）组成。

格式：

`(symbol1 symbol2 ... symbolN)`

所谓的 `符号` 是指连续的一串字符或数字。

IR 表达式分为 2 类：

- 结构表达式；
- 函数求值（即函数调用）表达式。

在不引起歧义的情况下，一般统一地称为表达式。

### 结构表达式

结构表达式用于组织源码，相当于一般高级语言里的 `语句（Statement）`。

IR 的结构表达式有：

- `Namespace 表达式`：命名空间的定义；
- `Data 表达式`：只读数据的定义；
- `Do 表达式`：表达式块；
- `Let 表达式`：局部变量的定义；
- `If 表达式`：条件控制；
- `Loop 表达式`（及其子表达式 `Break 表达式` 和 `Recur 表达式`）：循环控制；
- `Defn 表达式`：函数的定义；
- `Call 表达式`：函数的间接调用；
- `Closure 表达式`：封装数据；
- `Defnr 表达式`：带有尾部调用的函数的定义；

除了 `Do 表达式`、`If 表达式`、`Loop 表达式`（及其子表达式 `Break 表达式` 和 `Recur 表达式`）、`Call 表达式` 和 `Closure 表达式` 这几种结构表达式之外，其余结构表达式均无返回值。

结构表达式的格式：

`(name sub_exp1 sub_exp2 ... sub_expN)`

结构表达式的第一个部分是结构的名称，相当于一般高级语言 `语句` 当中的 `关键字`，其余部分是 `子表达式`。

一般 `子表达式` 可以是：

- 另外一个结构表达式；
- 函数求值表达式；
- 基本数据类型的 `字面量（Literal）`；
- `标识符`（`Identifier`，即函数、只读数据、局部变量的名称）；
- `元组`（`Tuple`）。

有些表达式会有额外的要求，详细情况见后面的章节。

示例：

```clojure
(if
    (ge x 60)
    (if
        (ge x 80)
        (add x 10)
        x
    )
    0
)
```

上例是一个 `If 表达式`，`If 表达式` 规定需要有 3 个子表达式组成。在上例中：

- 第一个子表达式是函数求值表达式 `(ge x 60)`；
- 第二个子表达式是另外一个 `If 表达式`；
- 第三个子表达式是数字字面量 `0`。

结构表达式里的各个子表达式并不一定都会被执行，比如上例中的 `If 表达式`，当条件 `(ge x 60)` 成立时，会执行第二个子表达式，不成立时，则会执行第三个子表达式，即第二、第三个子表达式两者当中只有一个会被执行。

### 函数求值表达式

函数求值也就是函数调用，函数求值表达式的格式是：

`(function_name arg1 arg2 ... argN)`

表达式的第一个部分是函数的名称，其余的部分是函数的参数。参数可以是：

- 基本数据类型的 `字面量`；
- `标识符`；
- `元组`。

注意跟一般 Lisp 语言不同，IR 函数求值表达式的参数 **不能** 是一个表达式（包括结构表达式和函数求值表达式），也就是说，在函数求值表达式里不允许表达式嵌套。

如果一个函数求值表达式的参数值来自于另外一个表达式的返回值，则需要先用一个局部变量接收该返回值，然后再把该局部变量作为参数传入到下一条函数求值表达式。

示例：

假设想求下面数学算式的值：

\[
\sqrt{3^2 + 4^2}
\]

一般的 Lisp 语言可以这样写：

```clojure
(sqrt (add (square 3) (square 4)))
```

但在 IR 里只能这样写：

```clojure
(let i (square 3))
(let j (square 4))
(let k (add i j))
(sqrt k)
```

IR 规定每个函数 **必须** 有返回值，对于确实无数据需要返回的函数，约定返回 `int` 类型的数字 `0`。

函数按类型可以分为：`内置函数` 和 `用户自定义函数`。

- 内置函数

  内置函数是 IR 自带的函数，包含有 `本地函数`（`Native function`，也叫本机函数） 和 `基础函数` 两种。本地函数对应着机器指令，如整数的乘除加减运算、整数的位运算等；基本函数是由运行时（runtime）提供基础功能，类似系统调用，比如分配内存等。

- 用户自定义函数

  即用户（程序员）定义的函数，`标准库` 的函数也属于用户自定义函数。

> 一个 IR 程序（或者库）实际上就是一堆并列的 "按照一定的逻辑和功能要求而组织的" 用户自定义函数的集合。

## IR 程序的源码结构

一个 IR 源文件最顶层只允许一个或并列多个 `Namespace 表达式`，在 `Namespace 表达式` 内只允许一个或并列多个 `Data 表达式`，`Defn 表达式` 和 `Defnr 表达式` 这 3 种表达式。

示例：

```clojure
(namespace ns1
    (data ...)
    (defn ...)
    (defnr ...)
    ...
)

(namespace ns2
    ...
)
```

### 注释

IR 支持单行注释，以分号 `;` 开始，直到句尾。注释的内容会被编译器忽略。

示例：

```clojure
; 这是一行注释
(let i 123) ; 从这里开始一直到行尾都是注释
```

### 标注

在表达式开始符号 `(` 前面添加 `@` 符号表示给该表达式添加标注，这些标注一般是给编译器使用的，比如标注 IR 代码对应的上层源码的位置信息等，示例：

```clojure
(namespace foo
    @source_map:line=12,column=4(defn test () (...))
)
```

## REPL 模式

REPL 模式一般存在于 IR 解析器，用于调试 IR 源码。在 REPL 模式下，默认在名为 `user` 的命名空间中，每一条表达式会立即被执行，但不支持直接执行 `Let 表达式`，它们必须写在 `Do 表达式` 或者函数定义表达式里。

在 REPL 模式下，也可以直接输入字面量、标识符或者元组，它们的值会被输出。

## 基本数据类型

IR 只支持 `i32`, `i64`, `f32` 和 `f64` 四种基本数据类型（Primitive Data Type）。在 IR 源码里可以直接表示这 4 种数据类型的字面量：

- 格式 `[\+\-]?[0-9]+` 会被解析为整型 `i64`；
- 如果数字字面量还包含有小数点或者字符 `e` 则会解析为浮点型 `f64`。

示例：

- i64: `123`, `-1`, `0`, `-456`
- f64: `2.718`, `6.626e-34`，`-1.23`，`3.0`

如果要表示 `i32` 和 `f32`，需要在字面量后面加上类型名称后缀。

示例：

- i32: `123i32`，`-456i32`
- f32: `3.14f32`, `-4.56f32`, `2.998e8f32`

IR 所有函数和表达式的运算结果只能是这几种数据类型。

### `int` 数据类型

`int` 数据类型是 `i32` 或 `i64` 的别名，编译器会根据目标机器环境自动选择它们其中之一。比如对于 `x86_64` 目标，它的实际类型是 `i64`，对于 WASM 32 目标，它的实际类型是 `i32`。

`int` 类型一般用于表示函数的索引、类型的索引、用户自定义数据的内存地址等场合。

### 标识符的数据类型表示方法

在 `标识符` 后面使用 `冒号（:） + 数据类型名称` 的方式表示其数据类型，示例：

- `x:i64`
- `foo:int`

### 字符串字面量

IR 程序代码中也有 `字符串字面量`，字符串字面量要使用双引号 `"` 包围起来，里面可以是任意字符。字符串支持转义字符 `\t`、`\n`、`\r`、`\\`、 `\"`，也可以使用 `\xHH` （H 不区分大小写）表示一个 8 bit 的字符编码，或者使用 `\u{H}` ~ `\u{HHHHHH}` （H 不区分大小写）表示一个 Unicode 码点，但不支持 `\uXXXX` 这种 Unicode 表示方法。

示例：

- `"hello"`
- `"世界你好"`
- `"\x68\x69\x20\u{6587}\u{5B57}"`

因为机器（包括虚拟机）并不支持 `字符串` 这种数据类型，所以 IR 的字符串跟上层语言的字符串并不相同。IR 的字符串字面量用两个用处：

- 用于实现上层语言的字符串字面量。上层语言的字符串字面量会在编译为 IR 的时候转成 `Data 表达式`，该表达式最终会被编译为程序的只读数据段里的一段数据；

- 用于实现上层语言的动态数据类型的方法调用以及`反射`（`Reflection`）功能。上层语言编译到 IR 时，一般会同时创建一个方法映射表，映射表记录这一个数据类型的所有方法，方法以函数名称的 `哈希` （`Hash`，`散列`）值作为 `键`（为了解决散列冲突，同时还会记录方法的名称），以函数的地址作为 `值`。在 IR 程序中，如果要调用动态数据类型的方法，则需要使用字符串字面量表示指定函数的名称，该名称最终会被编译为一个哈希值和一个只读数据。

### 元组

元组用于将多个数值（在形式上）封装起来形成一个整体。元组使用一对中括号表示，中括号里面列出需要封装的数值，数值之间使用空格分开，格式如下：

`[value1 value2 ... valueN]`

其中的数值可以是：

- 一个基本数据类型的字面量；
- 一个标识符；
- 一个元组。

元组里的数值 **不能** 是一个表达式，如果元组的数值来自一个表达式，则需要先使用一个局部变量接收再组成元组。

示例，下面是有效的元组：

```clojure
[2 3]
[i j k]
[10 m]
[i i [m n]]
```

下面是无效的元组：

```clojure
[(add i 1) (add i 2)]
```

注意 IR 的元组跟上层语言的元组并不相同。上层语言的元组接近一种匿名的结构体，而 IR 的元组仅仅用于表示多个必须 **成组** 出现的数据。

## 标识符的操作符

IR 支持在标识符名称前面添加操作符以实现指定的操作，类似 C 语言的取内存地址（指针）操作符 `&`。

操作符有如下几种：

- 引用只读数据 `#` 操作符
- 引用函数 `$` 操作符
- 访问闭包成员值的 `%` 操作符

示例：

```clojure
(data hello string "hello") ; 定义一个名为 `hello` 的只读数据
(defn foo ...)              ; 定义一个名为 `foo` 的函数
(let c (closure x y))       ; 定义一个名为 `c` 的标识符，其值是一个闭包

(puts #hello)               ; `#` 操作符表示获取只读数据 `hello` 对应的数据结构的地址
(map $foo data)             ; `$` 操作符表示获取名为 `foo` 的函数的地址
(let x %c.x)                ; `%` 操作符表示获取闭包 `c` 的成员 `x` 的值
```

各个操作符的详细信息见后面的章节。

## Namespace 表达式

一个 IR 程序（或者库）本质上是一堆并列的用户自定义函数，当一个程序规模较大时，所有函数堆在一起会比较难以维护。所以 IR 引入了一个叫做 `命名空间`（`namespace`）的概念，将函数按照相关性划分为一个一个的 `小组`，每一个 `小组` 就是一个 `命名空间`。

使用 `Namespace 表达式`（`Namespace expression`） 可以定义个命名空间。

示例：

```clojure
(namespace foo
    (data hello string "hello world")
    (defn inc (i) (add i 1))
    (defn dec (i) (sub i 1))
)
```

上面代码当中的 `foo` 是命名空间的名称，里面定义了一个 `只读数据` 及两个 `用户自定义函数`。

在一个模块（在其他编程语言里通常也称为 `包`，`package`）里，一个命名空间的代码不必一次过全部写完，可以分布到多个 `Namespace 表达式` 里，甚至可以分布到多个源代码文件，只要名称相同即可，编译器会把它们合并成同一个命名空间。示例：

```clojure
(namespace foo
    (data hello string "hello world")
)

(namespace foo
    (defn inc (i) (add i 1))
    (defn dec (i) (sub i 1))
)
```

上面的代码在编译时会被分别编译，但最后会合并为同一个命名空间 `foo`。当然，如果模块不同，即使名称相同，命名空间也是不同的。

名称空间实际上用于构建函数和只读数据的完整名称，函数和只读数据的完整名称格式如下：

`模块名称` + `.` + `命名空间名称` + `.` + `用户自定义函数或只读数据的名称`

这种名称也叫做 `标识符全称`（`Identifier full name`）。

假设上面的示例代码位于一个叫做 `mylib` 的模块里，则函数 `inc` 和 `dec` 以及只读数据 `hello` 的全称为：

- `mylib.foo.inc`；
- `mylib.foo.dec`；
- `mylig.foo.hello`。

当前模块的名称也可以使用代号 `module` 来代替，比如：

- `module.foo.inc`；
- `module.foo.dec`；
- `module.foo.hello`。

### 层次型命名空间

在给一个命名空间命名时，可以加上其他命名空间的名称作为前缀，以表示当前命名空间是指定命名空间下面的一个细分。名称和名称之间使用点号 `.` 分隔。

示例：

```clojure
(namespace foo
    ...
)

(namespace foo.bar
    ...
)

(namespace foo.bar.one
    ...
)
```

假设上面的示例代码位于一个叫做 `mylib` 的模块里，则它们构建了 3 个命名空间：

- `mylib.foo`；
- `mylib.foo.bar`；
- `mylib.foo.bar.one`。

这种通过将多个命名空间名称连接起来的名称也叫做 `命名空间路径`。

正如上一节所说的，命名空间（包括层次型命名空间）对 IR 来说仅仅用于构成 `标识符全称`，并没有多大的作用。但对于上层语言来说却不一样，上层语言的枚举数据类型、联合数据类型、泛型等，一般都是通过 IR 的层次型命名空间实现。

### 根命名空间

模块的顶层本身也是一个命名空间，称为 `根命名空间`。如果想把用户自定义函数定义在一个模块的根命名空间里，则需要传递 `()` （即一对空括号） 给 `Namespace 表达式` 的第一个子表达式。

示例：

```clojure
(namespace ()
    (def myfunc ...)
)
```

假设上面的示例代码位于一个叫做 `mylib` 的模块里，则函数 `myfunc` 的全称为 `mylib.myfunc`。

### 访问不同模块里的函数或只读数据

在一个模块里想访问另一个模块里的函数或只读数据，需要使用 `标识符全称`。比如现在有一个叫做 `mylib` 模块，代码如下：

```clojure
(namespace foo
    (defn inc ...)
)
```

现在还有一个叫 `example` 的模块，如果想在 `example` 模块里访问 `mylib` 里的函数 `inc`，则代码如下：

```clojure
(namespace ()
    (defn main ()
        (do
            (mylib.foo.inc ...) ;; 这里需要使用函数 inc 的全称
        )
    )
)
```

### 访问同一个模块但不同命名空间里的函数或只读数据

跟 "访问不同模块里的函数或只读数据" 的情况一样，需要使用 `标识符全称`。

比如现在有一个叫做 `mylib` 模块，现在有命名空间 `foo`，代码如下：

```clojure
(namespace foo
    (defn inc ...)
)

现在还有一个命名空间 `bar`，如果想在 `bar` 里访问 `foo` 里面的函数 `inc`，则代码如下：

(namespace bar
    (defn test ()
        (do
            (mylib.foo.inc ...) ;; 这里需要使用函数 inc 的全称
        )
    )
)
```

### 访问同一个命名空间里的函数或只读数据

在同一个命名空间里，访问函数或只读数据只需使用它们自身的名称即可，比如：

```clojure
(namespce foo
    (defn inc (i) ...)

    (defn incAndDouble (i)
        (let j (inc i)) ;; 这里只需使用函数 inc 自身的名称
        ...
    )
)
```

当然使用 `标识符全称` 总是有效的，也就是说，在上面的代码中如果使用 `inc` 函数的 `标识符全称` 也完全没问题。

正如前面提到，一个命名空间可能会分布到多个 `Namespace 表达式`，甚至可以分布到多个文件，"同一个命名空间" 包括了这些情况。

## Do 表达式

使用 `Do 表达式`（`Do expression`）可以将多个表达式组成一个 `表达式块`（`Expressions block`），在执行时，表达式块里的表达式将依次被执行，最后一个表达式（或者 `标识符`、`字面量`）的值将会作为表达式块的值被返回。

示例：

```clojure
(do
    (let a 10)
    (let b 20)
    (add a b)
)
```

上面代码创建了一个表达式块，里面有 3 个表达式，执行的顺序是：

1. 定义局部变量 `a`；
2. 定义局部变量 `b`；
3. 执行函数 `add` 将两个变量的值相加，相加的结果作为表达式块的值返回。

因为最后一个表达式返回值的数据类型是确定的，所以 `Do 表达式` 不需要指定返回值的数据类型，编译器会自动推断。

### 作用域

`Do 表达式` 同时还会创建一个独立的 `作用域`，作用域就是标识符的有效范围。我们常说的 `词法环境`（`Lexical Environment`） 正是由层次型的有效范围能构建的。

对于 IR 来说，作用域机制实际上不是必须的，之所以存在作用域机制，是为了保持跟上层语言有一致的结构。

#### 并列型作用域结构

示例：

```clojure
(do
    ;; 作用域 A
)
(do
    ;; 作用域 B
)
```

在上面的示例代码中，两个 `do` 表达式分别创建了两个作用域 `作用域 A` 和 `作用域 B`，位于这两个作用域之内的标识符完全不相干。并列作用域起到了有效范围的 "隔离" 效果。

示例：

```clojure
(do
    (let a 10)
)
(do
    ;; 这里无法访问 `a`
)
```

#### 层次型作用域结构

示例：

```clojure
(do
    ;; 作用域 A
    (do
        ;; 作用域 B
    )
    ;; 作用域 A
)
```

对于层次型的作用域，处于外层作用域的标识符的有效范围会覆盖到内层作用域，在上面的示例代码中，`作用域 A` 的有效范围会覆盖 `作用域 B`。也就是说：

- 在 `作用域 B` 里能直接访问 `作用域 A` 里已定义的局部变量；
- 反过来，在 `作用域 A` 里无法访问 `作用域 B` 里面的局部变量。

示例：

```clojure
(do
    (let a 10)
    (do
        (let b 20)
        ;; 这里可以访问 `a`
        ;; 这里没法访问 `c`
    )
    (let c 30)
    ;; 这里可以访问 `a`
    ;; 这里无法访问 `b`
)
```

#### 标识符名称冲突

IR 不允许在标识符（这里包括 `用户自定义函数`、`只读数据`、`局部变量`）的各自的作用域内定义同名的标识符。具体来说有以下几种情况：

1. 在同一个命名空间里，不能定义同名的用户自定义函数或只读数据。

示例：

```clojure
(namespace foo
    (data A ...)
    (data A ...)        ;; 只读数据 `A` 跟上一个只读数据 `A` 名称冲突
    (defn A ...)        ;; 函数 `A` 跟只读数据 `A` 名称冲突
    (defn B ...)
    (defn B ...)        ;; 函数 `B` 跟上一个函数 `B` 名称冲突
)
```

2. 不能定义跟当前命名空间内的函数、只读数据、或者当前函数的参数同名的局部变量。

示例：

```clojure
(namespace foo
    (defn hello (i) (do
        (let i 20)          ;; 局部变量 `i` 跟参数 `i` 名称冲突
        (let hello 10)      ;; 局部变量 `hello` 跟函数 `hello` 名称冲突
    ))

    (defn world (j) (do
        (let hello 10)      ;; 局部变量 `hello` 跟函数 `hello` 名称冲突
    ))
)
```

3. 在同一个作用域里，不能定义同名的局部变量。

示例：

```clojure
(do
    (let a 10)
    (let a 10)          ;; 跟前一个局部变量 `a` 冲突
    (do
        (let a 10)      ;; 跟上一层作用域里的局部变量 `a` 冲突
        (let b 20)
        (let c 30)
        ...
    )
    (let b 20)          ;; 跟上一个作用域里的局部变量 `b` **不冲突**
    (do
        (let c 30)      ;; 跟上一个作用域里的局部变量 `c` **不冲突**
        ...
    )
)
```

#### 拥有作用域的表达式

下面这些表达式都会创建自己的作用域。

- `Namespace 表达式`，如果多个 `Namespace 表达式` 表示同一个命名空间，则这几个 `Namespace 表达式` 共享同一个作用域；
- `Do 表达式`；
- `If 表达式`，准确来说是 `If 表达式` 的每个子表达式都各自创建了自己的作用域；
- `Loop 表达式`；
- `Defn 表达式`；
- `Defnr 表达式`。

## Data 表达式

`Data 表达式`（`Data expression`）用于将一个数据编译到程序的只读数据段里，这种数据称为 `只读数据`。

只读数据一般用于表示上层语言中的字符串字面量或者一些可以生成 `字节数组` 的字面量。并不是所有上层语言的 `常量` 都使用只读数据表示，对于上层语言数据类型当中 "可以表示为 IR 基本数据类型的" 常量（比如 XiaoXuan Lang 的 `整数`、`字符`、`逻辑` 等），在编译成 IR 时，会被 `预处理器` 替换掉所有引用这些常量的地方，所以并不需要生成只读数据。

> IR 的这种特性限制了上层语言的常量只能是：能够由基本数据类型表示，或者能转为 `字节数组` 的数据类型。

`Data 表达式` 语法如下：

`(data name type value)`

其中的 `name` 为只读数据的名称，`type` 为数据的类型，`value` 是用字符串表示的值。

示例：

```clojure
(data hello string "hello你好")
(data foo string "foo\x62\x61\x72\u{4F60}\u{597D}") ;; "foobar你好"
(data hippo byte "68 69 70 70 6F")
```

目前 `type` 只支持 `string`, `byte` 两种。其中：

- `string` 表示使用 utf-8 编码将值（`value`）转换为一系列字节数组，注意字节数组末尾不存在 `\x0`。
- `byte` 表示原始字节数组，其中的值（`value`）是一系列用 16 进制表示的字节的值，值不区分大小写，中间的空格可有可无。

### 操作符 `#`

上层语言中的每个字符串字面量，都会生成一个 `Data 表达式` （内容相同的字符串字面量可能会共享同一个 `Data 表达式`），但上层语言的程序使用字符串时，并不是直接使用该只读数据的地址。而是通过构建一个数据结构，该数据结构里有一个字段指向只读数据的地址，上层语言的程序在访问字符串时引用的是这个数据结构的地址。

所以在 IR 程序中引用只读数据时，需要在标识符前面添加操作符 ———— `#` 符号，示例：

```clojure
(namespace foo
    (data hello string "hello world")

    (defn test ()
        (do
            (let i:int #hello)      ;; 引用名字为 `hello` 的只读数据
            ...
        )
    )
)
```

如果命名空间不同，则需要使用 `标识符全称`，示例：

```clojure
(namespace bar
    (defn test ()
        (do
            (let j:int #foo.hello)  ;; 引用命名空间 `foo` 里面名字为 `hello` 的只读数据
            ...
        )
    )
)
```

## Let 表达式

`Let 表达式`（`Let expression`）用于在当前`有效范围`（`Scope`）之内创建一个局部变量并赋值，或者说，将一个值绑定到一个局部的 `标识符`。

语法：

`(let identifier_name:data_type value)`

其中第 1 个子表达式是标识符的名称，也就是局部变量的名称，第 2 个子表达式 `value` 用于传入待绑定的值，值可以是：

- 基本数据类型的字面量；
- 一个标识符；
- 一个有返回值的表达式；
- 一个元组。

示例：

```clojure
(let i:i64 123)
(let k:i32 (add 123 456))
```

`Let 表达式` 返回的值就是局部变量的值，比如上面示例当中的第一个表达式返回 `i64` 类型的 `123`。

`Let 表达式` 里的局部变量的数据类型实际上可以自动推断的，解析器或者编译器可自行决定是否允许省略数据类型的声明。

### 值的不变性

局部变量一旦创建，之后其值再也不能改变，这种限制可以简化编译器后端的实现。

### 值的复制

当将一个局部变量的值、函数参数的值或者函数的返回值赋值给一个局部变量时，会发生值的复制。

示例：

```clojure
(defn inc:i64 (a:i64)
    (do
        (let number 1)
        (let m number)  ;; 将局部变量 `number` 的值赋值给 `m`
        (let n a)       ;; 将参数 `a` 的值赋值给 `n`
        (add m n)
    )
)

(let i (inc 2))         ;; 将函数 `inc` 的返回值赋值给 `i`
```

### 元组的赋值

一个元组只能赋值给一个 `局部变量元组`，而无法赋值给一个局部变量。

`局部变量元组` 的格式跟普通元组类似，使用一对中括号表示，中括号里面是以空格分隔的多个局部变量。

示例：

```clojure
(let [i:i64 j:i64] [2 3])   ;; `[i:i64 j:i64]` 是一个 `局部变量元组`
```

如果元组有嵌套，则 `局部变量元组` 也必须有相同的结构。

示例：

```clojure
(let [i [a b] j] [1 [88 99] 3])
```

## If 表达式

`If 表达式` （`If expression`）是 `流程控制`（`Control flow`） 的一种，它会根据条件执行不同的分支，并返回该分支的值。

`If 表达式` 的语法如下：

`(if test_exp true_exp false_exp)`

`If 表达式` 有 3 个子表达式：

- `test_exp` 是条件表达式，其值只能是 `int` 类型的数字 `0` 或者 `1`，其中 `0` 表示逻辑 `false`，数字 `1` 表示逻辑 `true`。
- `true_exp` 表达式：当 `test_exp` 的值为 `1` 时会被执行的表达式。
- `false_exp` 表达式：当 `test_exp` 的值为 `0` 时会被执行的表达式。

示例：

```clojure
(do
    (let score 75)
    (if (ge score 60) 1 0)
)
```

上面的示例表示当变量 `score` 的值大于等于 `60` 时，返回 `1`，否则返回 `0`。

### 嵌套 `If 表达式`

使用嵌套的 `If 表达式` 可以表达复杂的逻辑，示例：

```clojure
(do
    (let score 80)
    (if (ge score 90)
        3
        (if (ge score 75)
            2
            (if (ge score 60) 1 0)
        )
    )
)
```

上面的示例里，表示根据变量 `score` 的值所在的范围分别返回 `int` 数字 `3`、`2`、`1` 或 `0`。

### `If 表达式` 的作用域

IR 规定 `If 表达式` 里的 3 个子表达式都有各自的作用域，也就是说，在这 3 个子表达式的任一个里面创建的局部变量，都仅仅在该子表达式内有效（如果不限制 `If 表达式` 的作用域，则会出现 "因为条件的不同而产生了不同的局部变量" 这种不确定的情况）。

为了避免歧义，如果 `If 表达式` 里的子表达式恰好是一个 `Let 表达式`，IR 的编译器会拒绝编译。

示例：

```clojure
(if (let i 100) ;; 编译器拒绝编译
    (...)
    (...)
)
```

```clojure
(if (eq x 100)
    (let i 100) ;; 编译器拒绝编译
    (...)
)
```

```clojure
(if (eq x 100)
    (...)
    (let i 100) ;; 编译器拒绝编译
)
```

如果需要在 `If 表达式` 的子表达式里创建局部变量，需要写在 `Do 表达式` 里，示例：

```clojure
(if (eq x 100)
    (do
        (let i 100)
        ...
    )
)
```

如果要创建一个仅限当前 `If 表达式` 使用的局部变量，可以把 `If 表达式` 写在一个 `Do 表达式` 里，示例：

```clojure
(do
    (let i 100) ;; 局部变量 `i` 仅在下面的 `If 表达式` 里有效。
    (if
        ...
    )
)
```

## Loop 表达式

`Loop 表达式`（`Loop expression`）也是 `流程控制` 的一种，用于重复执行目标表达式（也叫做 `循环体`，`Loop body`）。

一个完整的循环结构还需要 2 个关联的表达式 ———— `Break 表达式` 和 `Recur 表达式` 共同完成，这几个表达式的作用分别是：

1. `Loop 表达式` 用于定义 `循环变量` 及其初始值；
2. `Break 表达式` 用于中断循环并返回指定的值；
3. `Recur 表达式` 用于更新 `循环变量` 的值并再次执行 `循环体`。

`Loop 表达式` 的语法是：

`(loop [param1:data_type param2:data_type ...] [init_value1 init_value2 ...] loop_body)`

各子表达式的作用：

- 第一个子表达式是 `循环变量` 元组。所谓 `循环变量` 是指在每次循环里其值都不同标识符，相当于函数的 `形参`（`Parameter`）；
- 第二个子表达式是 `循环变量` 的初始值元组；
- 第三个子表达式是被重复执行的目标表达式，它是一个内部含有 `Break 表达式` 和 `Recur 表达式` 的表达式。

目标表达式最后需要返回一个元组：

- 如果返回的元组有两个元素，且第一个元素的值为 `int` 数字 `0`，比如 `(0 123)`，则表示中止循环，并把第二个元素 `123` 作为整个 `Loop 表达式` 的值。
- 如果返回的元组有一个或多个元素，且第一个元素的值为 `int` 数字 `1`，比如 `(1 77 88)`，则表示用第一个元素之外的其余元素重新传入 `Loop 表达式` 的 `循环变量`，然后再执行一次目标表达式。

在语法上，IR 约定必须使用 `Break 表达式` 和 `Recur 表达式` 构造上述的元组。实际上 `(break 123)` 就是返回元组 `[0 123]`，而 `(recur 77 88)` 就是返回元组 `[1 77 88]`；

需注意：

- `Break 表达式` 和 `Recur 表达式` 的子表达式只能是标识符或者基本数据类型的字面量。
- `Break 表达式` 和 `Recur 表达式` 必须位于目标表达式（表达式块）的最后一句；
- 如果目标表达式里面包含有分支，则必须保证每个分支的最后一句必须是 `Break 表达式` 或者 `Recur 表达式`。

示例：

```clojure
(loop [index length sum] [1 10 0]
    (if (gt index length)
        (break sum)
        (do
            (let next_sum (add index sum))
            (let next_index (add index 1))
            (recur next_index length next_sum)
        )
    )
)
```

上面示例实现了算式 \(1 + 2 + 3 + .. + 10 = 55\)，过程是：

1. 让循环变量 `index` 从数字 `1` 增长到 `11`；
2. 在每次增长过程中，都让循环变量 `sum` 加上当次循环变量 `index` 的值；
3. 当循环变量 `index` 的值大于 10 时，中止循环；
4. 最后，`Loop 表达式` 返回循环变量 `sum` 的值，即数字 `55`。

## Defn 表达式

`Defn 表达式`（`Defn expression`）用于定义函数，这类由用户（程序员）创建的函数叫做 `用户自定义函数`。

`Defn 表达式` 的格式如下：

`(defn function_name:data_type (param1:data_type param2:data_type ... paramN:data_type) function_body)`

`Defn 表达式` 的第 2 个子表达式是参数名列表，如果函数没有参数，则写上一对空括号 `()`；第 3 个子表达式是函数的主体，主体可以是一个字面量、标识符、元组或者另外一个表达式。

示例：

```clojure
(defn double:i64    ;; 函数名称及其返回值数据类型
    (x:i64)         ;; 参数及其数据类型的列表
    (mul x 2)       ;; 函数主体
)
```

IR 规定每个函数 **必须** 有返回值，对于确实无数据需要返回的函数，约定返回 `int` 类型的数字 `0`。

函数的返回值数据类型也是可以自动推断的，解析器或者编译器可自行决定是否允许省略函数返回值数据类型的声明。

### 元组返回值

当一个函数需要返回的值不止一个时，可以将多个值封装为一个元组，然后再返回这个元组。

需要注意的是如果函数要返回一个元组，则函数的返回值类型必须是一个 `类型元组`。`类型元组` 的格式跟普通元组类似，也是使用一对中括号表示，中括号里面是以空格分隔的多个数据类型的名称。

示例：

```clojure
(defn swap:[i64 i64]    ;; `[i64 i64]` 是一个 `类型元组`
    (a:i64 b:i64)
    [b a]
)
```

调用返回值为元组的函数时，只能使用 `局部变量元组` 来接收。

示例：

```clojure
(let [m:i64 n:i64] (swap 2 8))  ;; `[m:i64 n:i64]` 是一个 `局部变量元组`
```

### 元组参数

元组也可以作为函数的参数，在函数的参数列表里使用 `局部变量元组` 即可。

IR 支持元组参数主要是为了让函数的定义能跟上层语言有一致的结构。有时上层语言的一个函数参数可能需要 IR 的多个数值来表示，比如 XiaoXuan Lang 的 `特性/接口` 类型的参数，也就是动态数据类型，实际上它是由两个数据组成（一个数据表示实参的数据类型，另一个数据表示实参的具体的值）。

示例，假设有如下的上层语言代码：

```js
function void say(String s, dyn Writer w) {
    w.writeLine(s);
}
```

则对应的 IR 代码大致如下：

```clojure
(defn say:int (
    s:int                       ;; 对应着 `String s`
    [w_type:int w_value:int]    ;; 对应着 `dyn Writer w`
    )
    (let f:int (lookup w_type "writeLine"))
    (call:int f s)
)
```

调用含有元组类型参数的函数时，传入该参数的值也必须是元组。

示例，假设有如下的上层语言代码：

```js
let s = "hello";
let w = std::out;
say (s, w);
```

则对应的 IR 代码大致如下：

```clojure
(data hello string "hello")
...
(do
    (let s:int #hello)
    (let w_type:int ...)
    (let w_value:int ...)
    (say s [w_type w_value])    ;; `w_type` 和 `w_value` 封装成元组
)
```

## Call 表达式

`Call 表达式` （`Call expression`） 用于根据函数的地址来调用一个函数。

`Call 表达式` 的格式是：

`(call func_addr arg1 arg2 ... argN)`

其中第一个子表达式是一个函数的地址，后面的是参数，参数只能是标识符或者基本数据类型的字面量。

### 操作符 `$`

使用操作符 `$` 可以获取指定函数的地址。当需要把一个函数作为参数传递给另外一个函数，需要在函数的名称前面使用操作符 `$` 取得该函数的地址，然后把这个地址作为参数传给目标函数。

也就是说，目标函数需要的其实是函数的地址（一个 `int` 类型的值），而不是函数本身。

示例，假设现有如下 3 个函数：

```clojure
(defn isGreaterThanTen (x:i64) (gt x 10))
(defn isEqualsToZero (x:i64) (eq x 0))
(defn assert (func:int value:i64)
    (call func value)
)
```

现在要把函数 `isGreaterThanTen` 和 `isEqualsToZero` 作为参数传给函数 `assert`，示例：

```clojure
(assert $isGreaterThanTen 0)    ;; 返回 0
(assert $isGreaterThanTen 20)   ;; 返回 1
(assert $isEqualsToZero 0)      ;; 返回 1
(assert $isEqualsToZero 20)     ;; 返回 0
```

### 匿名函数的实现

现代的编程语言一般都支持匿名函数（也称为 `Lambda`），但 IR 并不直接支持在 `用户自定义函数` 里面再定义函数，也就是说无法定义匿名函数，但可以通过变通的方法实现。

上层语言把程序编译为 IR 时，只需把匿名函数代码段抽离出来，视为一个普通的 `用户自定义函数` 来定义即可。函数的名称由编译器自动生成。

示例，假如有如下上层语言的代码：

```js
function assert(func, value) {
    func(value)
}

let a = assert(x => x>10, 20);
```

使用 IR 实现的代码大致如下：

```clojure
(defn assert (func:int value:i64)
    (call func value)
)

(defn _anonymous_func_1 (x:i64)     ;; 自动生成的匿名函数
    (gt x 10)
)

(let a (assert $_anonymous_func_1 20))
```

## Closure 表达式

`Closure 表达式`（`Closure expression`）用户封装多个数据到一个内部的数据结构，并返回该数据结构的地址。 `Closure 表达式` 用于实现 `闭包`（`Closure`）功能。

现代的编程语言的匿名函数一般支持闭包特性，所谓闭包就是将该匿名函数所引用到的外部变量封装起来（也叫做捕获词法环境的标识符），然后作为函数的一部分，无论该匿名函数被传递到哪里，它总能访问到它所捕获的值。

各种语言实现闭包的方法不尽相同，有些会把所有被捕获的值作为额外的参数罗列在匿名函数的参数列表后面；有些则先把所有捕获的值封装起来，然后作为一个整体数据，只在匿名函数后面添加一个额外的参数用来传递该整体数据。前者因为不需要用到堆内存，所以运行效率高，但需要针对每种捕获情况编译相应的匿名函数，实现起来比较复杂；后者需要用到堆内存，运行效率较低，但编译器的实现比较简单。

IR 采用的是后一种实现方式。`Closure 表达式` 的作用正是用于创建了一个受内存管理的内部结构体，结构体里包含有各个标识符的名称（或者索引）以及它们的值。

`Closure 表达式` 的格式是：

`(closure id1 id2 ... idN)`

表达式里的各子表达式是当前环境的标识符，表达式返回的是一个 `int` 类型的值。

示例，下面的示例演示了如何封装两个标识符：

```clojure
(let x 10)
(let y 20)
(let c (closure x y))
)
```

### 操作符 `%`

操作符 `%` 用于访问闭包里的各个成员的值，示例：

```clojure
(let i (%c.x))
(let j (%c.y))
```

### 匿名函数的闭包的实现

如果匿名函数引用了所在环境的标识符，则生成该匿名函数时需要在后面多添加一个参数，用于传入闭包数据。

示例，假如有如下上层语言的代码：

```js
function between(min, max) {
    x => {
        x > min && x < max
    };
}

function assert(func, value) {
    func(value);
}

let f = between(20, 80);
let a = assert(f, 30);
```

使用 IR 实现的代码大致如下：

```clojure
(defn _between_anonymous_func_1 (x c)        ;; 自动生成的匿名函数
    (let min %c.min)
    (let max %c.max)
    (and
        (gt x min)
        (lt x max)
    )
)

(defn between (min max)
    (let c (closure min max))
    [$_between_anonymous_func_1 c]
)

(defn assert ([func c] value)
    (call func value c)
)

(let [f c] (between 20 80))
(let a (assert [f c] 30))
```

因为 IR 这种对于匿名函数闭包的实现方式，IR 有如下约束：

- 上层语言的一个 `函数类型` 的变量需要使用一个 "含有两个元素的" 元组来表示，第一个元素是函数的地址，第二个元素是闭包的地址，这种固定的搭配称为 `函数元组`；
- 如果一个函数需要返回一个函数，则必须返回一个函数元组；
- 如果一个函数的参数需要接受一个函数，则该参数必须是一个函数元组。

## Defnr 表达式

`Defnr 表达式`（`Defnr expression`） 用于定义一个需要调用自身的函数（即递归调用的函数）。虽然使用 `Defn 表达式` 定义的函数也支持递归调用自身，但 `Defnr 表达式` 会进行 `尾部调用优化`（`Tail call optimization`）。`尾部调用优化` 能避免程序在运行时创建过多的调用栈，从而提高运行效率。

`Defnr 表达式` 的结构跟 `Loop 表达式` 非常相似，详细见 [Loop 表达式](#loop-表达式) 一节。

示例：

```clojure
(defnr sum_1 (index count sum)
    (if (gt index count)
        (break sum)
        (do
            (let next_index (add index 1))
            (let next_sum (add index sum))
            (recur next_index count next_sum)
        )
    )
)

(defn sum (start end)
    (sum_1 start end 0)
)

(let i (sum 1 100))     ;; 返回 5050
```

上面的示例演示了一个从整数 `start` 累加到 `end` 的程序。
