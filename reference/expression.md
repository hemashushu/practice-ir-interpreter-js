# 表达式

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [表达式](#表达式)
  - [基本数据类型](#基本数据类型)
    - [`int` 和 `ptr` 数据类型](#int-和-ptr-数据类型)
  - [基本语法](#基本语法)
    - [结构表达式](#结构表达式)
    - [函数求值表达式](#函数求值表达式)
  - [XiaoXuan Lang IR 程序的源码结构](#xiaoxuan-lang-ir-程序的源码结构)
  - [REPL 模式](#repl-模式)
  - [命名空间表达式](#命名空间表达式)
    - [层次型命名空间](#层次型命名空间)
    - [根命名空间](#根命名空间)
    - [访问不同模块里的标识符](#访问不同模块里的标识符)
    - [访问同一个模块同一个命名空间里的标识符](#访问同一个模块同一个命名空间里的标识符)
    - [访问同一个模块但不同命名空间里的标识符](#访问同一个模块但不同命名空间里的标识符)
  - [表达式块](#表达式块)
    - [作用域](#作用域)
      - [标识符名称冲突](#标识符名称冲突)
  - [静态数据表达式](#静态数据表达式)
  - [局部变量表达式](#局部变量表达式)
    - [值的不变性和复制](#值的不变性和复制)
  - [条件控制表达式](#条件控制表达式)
    - [条件表达式的作用域](#条件表达式的作用域)
  - [循环控制表达式](#循环控制表达式)
  - [用户自定义函数表达式](#用户自定义函数表达式)
    - [元组](#元组)
    - [递归调用的函数](#递归调用的函数)
    - [匿名函数](#匿名函数)
  - [注释](#注释)
  - [标注](#标注)
  - [语言约束](#语言约束)

<!-- /code_chunk_output -->

XiaoXuan Lang IR 是 XiaoXuan Lang （或其他上层语言） 编译为目标程序（本地代码或者 WASM 字节码）过程中的中间代码，它是对常见的机器指令和程序结构的简单抽象和封装。

> XiaoXuan Lang IR 并不是直接面向用户（程序员）的编程语言，也不是 Lisp 方言。

## 基本数据类型

XiaoXuan Lang IR 只支持 `i32`, `i64`, `f32` 和 `f64` 四种基本数据类型（Primitive Data Type）。在 XiaoXuan Lang IR 源码里可以直接表示这 4 种数据类型的字面量：

- 格式 `[\+\-]?[0-9]+` 会被解析为整型 `i64`；
- 如果数字字面量还包含有小数点或者字符 `e` 则会解析为浮点型 `f64`。

示例：

- i64: `123`, `-1`, `0`, `-456`
- f64: `2.718`, `6.626e-34`，`-1.23`，`3.0`

如果要表示 `i32` 和 `f32`，需要在字面量后面加上 `s` 字符后缀。

示例：

- i32: `123s`，`-456s`
- f32: `3.14s`, `-4.56s`, `4.0s`

XiaoXuan Lang IR 所有函数和表达式的运算结果只能是这几种数据类型。

### `int` 和 `ptr` 数据类型

XiaoXuan Lang IR 还支持名为 `int` 和 `ptr` 的数据类型，它们都是 `i32` 或 `i64` 的别名，编译器会根据目标机器环境自动选择它们其中之一，对于目标 WASM，则等同于 `i64`。

`ptr` 类型用于表示用户自定义数据的内存地址，`int` 类型用于表示函数的索引、类型索引。

## 基本语法

XiaoXuan Lang IR 源码由 [S-表达式](https://en.wikipedia.org/wiki/S-expression) 组成，`S-表达式` 由一对圆括号里面包含一个或多个由空格分开的 `符号`（`Symbol`）组成。`符号` 包括连续的一串字符、数字字面量、双引号包围起来的字符串字面量等。

格式：

`(symbol1 symbol2 ... symbolN)`

XiaoXuan Lang IR 表达式大致可以分为 2 类：结构表达式和函数求值（调用）表达式。

### 结构表达式

结构表达式用于组织源码，相当于一般高级语言里的 `语句（Statement）`。

XiaoXuan Lang IR 的结构表达式有：

- `namespace` 命名空间的定义
- `data` 静态数据的定义
- `do` 表达式块
- `let` 局部变量的定义
- `if` 条件控制
- `loop`、`break` 和 `recur` 循环控制
- `defn` 和 `defnr` 函数的定义
- `call` 函数调用

结构表达式的格式：

`(name sub-exp1 sub-exp2 ... sub-expN)`

表达式的第一个部分是结构的名称，相当于一般高级语言的 `关键字`，其余部分是 `子表达式`。

`子表达式` 可以是另外一个结构表达式，可以是函数求值表达式，还可以是基本数据类型的 `字面量（Literal）` 或者 `标识符`（`Identifier`，即函数、静态数据、变量等的名称）。

示例：

```clojure
(if
    (ge x 60)
    (if
        (ge x 80)
        (add x 10)
        x
    )
    0
)
```

上例是一个 `if` 结构表达式，`if` 表达式规定需要有 3 个子表达式组成。在上例中：

- 第一个子表达式是函数求值表达式 `(ge x 60)`；
- 第二个子表达式是另外一个 `if` 结构表达式；
- 第三个子表达式是字面量 `0`。

结构表达式里的各个子表达式并不一定都会被执行，比如上例中的 `if` 结构表达式，当条件 `(ge x 60)` 成立时，会执行第二个子表达式，不成立时，则会执行第三个子表达式，即第二、第三个子表达式只有其中一个会被执行。

### 函数求值表达式

函数求值表达式的格式是：

`(function-name arg1 arg2 ... argN)`

表达式的第一个部分是函数的名称，其余的部分是函数的参数。参数既可以是基本数据类型的 `字面量`，也可以是 `标识符`，但跟一般 Lisp 不同，参数 **不能** 是一个有返回值的结构表达式或者另一个函数求值表达式，这是因为 XiaoXuan Lang IR 的内存管理方式所限制的。

也就是说，如果一个函数求值表达式的参数值来自于另外一个函数求值表达式的返回值，则应该先用一个变量接收该返回值，然后再把该变量作为参数传入下一条函数求值表达式。示例：

假设想求下面数学算式的值：

\[
\sqrt{3^2 + 4^2}
\]

不能这样写：

```clojure
(sqrt (add (square 3) (square 4)))
```

而应该写成：

```clojure
(let i (square 3))
(let j (square 4))
(let k (add i j))
(sqrt k)
```

XiaoXuan Lang IR 规定每个函数 **必须** 有返回值，对于确实不具备返回意义的表达值，约定返回 `int` 类型的数字 `0`。

函数按类型可以分为：`本地函数`、`内置函数` 和 `用户自定义函数`。

- 本地函数

  本地函数对应着机器指令，如整数的乘除加减运算、整数的位运算等。

- 内置函数

  内置函数是运行时（runtime）所必须的基础功能，类似系统调用，比如分配内存等。

- 用户自定义函数

  即用户（程序员）定义的函数，标准库的函数也属于用户自定义函数。

> 一个 Xiaoxuan Lang IR 应用程序的实际上就是一堆 "按照一定的逻辑和功能要求而组织的" 用户自定义函数。

## XiaoXuan Lang IR 程序的源码结构

一个 XiaoXuan Lang IR 源文件最顶层只允许一个或并列多个 `namespace` 表达式，在 `namespace` 表达式内只允许并列一个或多个 `data`，`defn` 和 `defnr` 这 3 种表达式。

示例：

```clojure
(namespace ns1
    (data ...)
    (defn ...)
    (defnr ...)
    ...
)

(namespace ns2
    ...
)
```

## REPL 模式

REPL 模式用于学习和调试 XiaoXuan Lang IR 解析器或编译器。在 REPL 模式下，默认在名为 `user` 的命名空间中，每一条表达式会立即被执行，但不支持直接执行 `let` 表达式，它们必须写在 `do` 表达式或者函数表达式里。

在 REPL 模式下，也可以直接输入字面量或者标识符，字面量和标识符的值会被输出。

## 命名空间表达式

XiaoXuan Lang IR 程序由一堆并列的用户自定义函数和常量组成，当一个程序规模较大时，所有函数堆在一起会比较难以维护。所以 XiaoXuan Lang IR 引入了一个叫做 `命名空间`（`namespace`）的概念，将函数按照相关性划分为一个一个的 `小组`，每个 `小组` 就是一个 `命名空间`。

示例：

```clojure
(namespace foo
    (data #hello_world string "hello world")
    (defn inc (i) (add i 1))
    (defn dec (i) (sub i 1))
)
```

上面代码当中的 `foo` 是命名空间的名称，里面定义了一个常量及两个用户自定义函数。

在一个模块（在其他编程语言里也叫做 `包`，`package`）里，一个命名空间的代码不必一次过全部写完，可以分布到多个 `namespace` 表达式里，甚至可以分布到多个源代码文件，只要名称相同即可，编译器会把它们合并成同一个命名空间。示例：

```clojure
(namespace foo
    (data #hello_world string "hello world")
)

(namespace foo
    (defn inc (i) (add i 1))
    (defn dec (i) (sub i 1))
)
```

上面的代码在编译时会被分别编译，但最后会合并为同一个命名空间 `foo`。

当然，如果模块不同，即使名称相同，命名空间也是不同的。

名称空间实际上用于构建函数的完整名称，函数（或者说标识符）的完成名称格式如下：

`模块名称` + `.` + `命名空间名称` + `.` + `用户自定义函数的名称`

这种名称也叫做 `标识符的全称`（`Identifier full name`）。

假设上面的示例代码位于一个叫做 `mylib` 的模块里，则函数的全称为：

- `mylib.foo.inc`
- `mylib.foo.dec`

注： `namespace` 表达式是用于组织代码的特殊表达式，表达式没有返回值。

### 层次型命名空间

在给一个命名空间命名时，可以为它加上其他命名空间的名称作为前缀，以表示当前命名空间是目标命名空间下面的一个细分。名称和名称之间使用点号 `.` 分隔。

示例：

```clojure
(namespace foo
    (defn A ...)
)

(namespace foo.bar
    (defn B ...)
)

(namespace foo.bar.one
    (defn C ...)
)
```

假设上面的示例代码位于一个叫做 `mylib` 的模块里，则它们构建了 3 个命名空间 `mylib.foo`、`mylib.foo.bar` 和 `mylib.foo.bar.one`。这种通过将多个命名空间名称连接起来的名称也叫做 `命名空间路径`。

正如上一节所说的，命名空间（包括层次型命名空间）对 XiaoXuan Lang IR 来说仅仅用来组成 `标识符全称`。但对于上层语言来说却有更多的作用和意义，比如可以将相关功能更细致地分组，可以更好地组织源代码，可以保护内部方法不被外部访问等。因此上层语言编译成 XiaoXuan Lang IR 时，通常会存在多层命名空间。

### 根命名空间

跟当前模块的名称同名的命名空间，被称为 `根命名空间`。如果想把用户自定义函数定义在一个模块的根命名空间里，则需要传参数 `()` （即一对空括号） 给 `namespace` 表达式的第一个参数。

示例：

```clojure
(namespace ()
    (def D ...)
)
```

假设上面的示例代码位于一个叫做 `mylib` 的模块里，则函数 `D` 的全称为 `mylib.D`。

### 访问不同模块里的标识符

在一个模块里想访问另一个模块里的标识符，需要把这个 `标识符的全称` 写出来。比如现在有一个叫做 `example` 模块，想访问上例当中的函数 `B`，则代码如下：

```clojure
(namespace ()
    (defn main () (do
        (mylib.foo.B ...)
    ))
)
```

### 访问同一个模块同一个命名空间里的标识符

在同一个模块的同一个命名空间里，访问标识符只需书写标识符自身的名称即可，比如：

```clojure
(namespce foo
    (defn inc (i) (add i 1))
    (defn incAndDouble (i)
        (let j (inc i))
        (mul j 2)
    )
)
```

在上面的代码中，函数 `incAndDouble` 里调用了函数 `inc`，只需直接书写 `inc` 函数的自身名称即可，而不需要写诸如 `mylib.foo.inc` 的标识符全称。

### 访问同一个模块但不同命名空间里的标识符

在同一个模块里，如果要访问不同的命名空间里的标识符，跟访问不同模块的标识符情况一下，需要写上 `标识符的全称`。

假设当前模块的名称为 `mylib`，上面代码创建了一个命名空间 `foo`，现在有另外一个命名空间 `foo.bar`，如果想访问 `foo` 命名空间里面的函数 `A`，则代码如下：

```clojure
(namespace foo.bar
    (defn hello ()
        (mylib.foo.A ...)
    )
)
```

## 表达式块

使用块表达式（`do` 表达式）可以将多个表达式组成一个 `表达式块`，在执行时，表达式块里的表达式将依次被执行，最后一个表达式（或者标识符、字面量）的值将会作为表达式块的值被返回。

示例：

```clojure
(do
    (let a 10)
    (let b 20)
    (add a b)
)
```

上面代码创建了一个表达式块，里面有 3 个表达式，先执行变量 `a` 和变量 `b` 的定义表达式，然后执行表达式 `(add a b)` 将两个变量的值相加，最后相加的结果作为表达式块的值返回。

因为最后一个表达式返回值的数据类型是确定的，所以块表达式不需要指定返回值的数据类型，编译器会自动推断。

### 作用域

块表达式同时还会创建一个独立的 `作用域`。作用域就是标识符的有效范围，作用域的结构可以是并列的，示例：

```clojure
(do
    ;; 作用域 A
)
(do
    ;; 作用域 B
)
```

在上面的示例代码中，两个 `do` 表达式分别创建了两个作用域 `作用域 A` 和 `作用域 B`，位于这两个作用域之内的标识符完全不相干。并列作用域起到了有效范围的 "隔离" 效果。

示例：

```clojure
(do
    (let a 10)
)
(do
    ;; 这里无法访问 `a`
)
```

作用域也可以是层次型的，示例：

```clojure
(do
    ;; 作用域 A
    (do
        ;; 作用域 B
    )
    ;; 作用域 A
)
```

对于层次型的作用域，处于外层作用域的标识符的有效范围会覆盖到内层作用域，在上面的示例代码中，`作用域 A` 的有效范围会覆盖 `作用域 B`。也就是说在 `作用域 B` 里能直接访问 `作用域 A` 里的所有标识符（当然要求是在第 2 个 `do` 表达式之前就已经定义的标识符）。但反过来，在 `作用域 A` 里无法访问 `作用域 B` 里面的标识符。

```clojure
(do
    (let a 10)
    (do
        (let b 20)
        ;; 这里可以访问 `a`
        ;; 这里没法访问 `c`
    )
    (let c 30)
    ;; 这里可以访问 `a`
    ;; 这里无法访问 `b`
)
```

#### 标识符名称冲突

XiaoXuan Lang IR 不允许在标识符（包括 `用户自定义函数`、`局部变量`）的 `作用域` 内定义同名的标识符。具体来说有一下几种情况：

1. 在同一个命名空间里，不能定义同名的用户自定义函数。

示例：

```clojure
(namespace foo
    (defn A ...)
    (defn A ...) ;; 函数 `A` 跟上一个函数 `A` 名称冲突
)
```

2. 不能定义跟当前命名空间内的函数、或者当前函数的参数同名的局部变量。

示例：

```clojure
(namespace foo
    (defn hello (i) (do
        (let hello 10) ;; 局部变量 `hello` 跟函数 `hello` 名称冲突
        (let i 20)     ;; 局部变量 `i` 跟参数 `i` 名称冲突
    ))

    (defn world (k) (do
        (let hello 10) ;; 局部变量 `hello` 跟函数 `hello` 名称冲突
    ))
)
```

3. 在同一个作用域里，不能定义同名的局部变量。

示例：

```clojure
(do
    (let a 10)
    (do
        (let a 10)  ;; 跟上一层作用域里的 `a` 冲突
        (let b 20)
        (let c 30)
        ...
    )
    (let b 20)      ;; 不会跟上一个作用域里的 `b` 冲突
    (do
        (let c 30)  ;; 不会跟上一个作用域里的 `c` 冲突
        ...
    )
)
```

注：每个 `用户自定义函数`、`loop` 表达式，都隐含地创建了自己的作用域，另外在 `if` 表达式里，如果要创建局部变量，也会被要求创建自己的作用域。

## 静态数据表达式

静态数据表达式（`data` 表达式）用于将一个数据编译到程序的只读数据段里。

一般来说，静态数据一般都是上层语言程序中的字符串字面量。另外还有上层语言程序中的非基本数据类型的常量，至于基本数据类型的常量，因为在编译成 XiaoXuan Lang IR 时已经被 `预处理器` 自动替换到所有引用的地方，所以并不需要生成静态数据。

静态数据表达式语法如下：

`(data name type value)`

示例：

```clojure
(data hello string "hello")
(data foo string "foo")
```

需注意的是：

- 静态数据位于程序的只读数据段里，因此不会被资源回收，也不参与引用计数计算。
- 对于出现在程序当中的字符串字面量，也需要使用静态数据表达式生成静态数据，至于名称则可以由编译器自动生成。
- 在程序中可以通过静态数据标识符引用该数据，如果命名空间不同，则需要写出该标识符的全称。

## 局部变量表达式

局部变量表达式（`let` 表达式）用于在当前`有效范围`（Scope，有效范围构建出 `词法环境`，`Lexical Environment`）之内创建一个局部变量并赋值，或者说，将一个值绑定到一个局部的 `标识符`。

语法：

`(let variable-name:data-type value)`

其中第 2 个子表达式 `value` 用于传入待绑定的值，值可以是基本数据类型的字面量，也可以是一个标识符，或者另一个有返回值的表达式，示例：

```clojure
(let i:i64 123)
(let k:i32 (add 123 456))
```

`let` 表达式会返回标识符的值，比如上面示例当中的第一个表达式返回 `i64` 类型的 `123`。

`let` 表达式里的标识符的数据类型使用一个冒哈 `:` + `数据类型名称` 表示，不过因为所有函数求值表达式返回值的数据类型、标识符的数据类型、以及字面量的数据类型都是确定的，所以并不一定需要指定标识符的数据类型，编译器会自动推断。因此上面的示例也可以写成：

```clojure
(let i 123)
(let k (add 123 456))
```

无论标识符的数据类型是否写上，编译器都会自动推断类型，如果标上了数据类型，则还会检查是否一致。

### 值的不变性和复制

一个标识符也可以赋值给另外一个标识符，示例：

```clojure
(let i 123)
(let j i)
```

将一个标识符赋值给另外一个标识符，具体过程如下：

- 如果标识符的值为基本数据类型，则值会被直接复制；
- 如果标识符的值为用户自定义类型，因为所有用户自定义类型的数据都存储在堆里（相当于其他语言的引用类型变量），标识符的值实际上是数据的指针（即数据在内存的地址），所以在复制此类标识符的值时，实际上是复制了指针的值，当然还需要（手动）增加目标数据的引用计数值，当程序执行到标识符的作用范围之外时，需要（手动）减少目标数据的引用计数值。
- 如果标识符的值为用户自定义函数，标识符的值实际上是一个元组，包含函数的指针和一个闭包的指针，函数的指针和函数类型会直接复制，而闭包的指针（如果值不为 0）跟用户自定义类型一样处理。
- 如果标识符是动态数据类型，标识符的值实际上是一个元组，包含数据的实际类型和一个数据的值或指针。

有关增加和减少引用计数值的详细内容，请见 [用户自定义数据和内存管理](user-defined-data-and-memory-management.md) 一章。

## 条件控制表达式

使用条件控制表达式（`if` 表达式）可以根据条件执行不同的分支，并返回该分支的值，条件控制表达式的语法如下：

`(if condition_exp true_exp false_exp)`

条件控制表达式有 3 个子表达式。其中子表达式 `condition_exp` 表示条件，其值只能是 `int` 类型的数字 `0` 或者 `1`，其中 `0` 表示逻辑 `false`，数字 `1` 表示逻辑 `true`。

当 `condition_exp` 的值为 `1` 时，`true_exp` 表达式会被执行并返回它的值，当 `condition_exp` 的值为 `0` 时，`false_exp` 表达式会被执行并返回它的值。

示例：

```clojure
(do
    (let score 75)
    (if (ge score 60) 1 0)
)
```

上面的代码表示当变量 `score` 的值大于等于 `60` 时，返回 `1`，否则返回 `0`。

使用嵌套 `if` 表达式可以表达复杂的逻辑，示例：

```clojure
(do
    (let score 80)
    (if (ge score 90)
        3
        (if (ge score 75)
            2
            (if (ge score 60) 1 0)
        )
    )
)
```

上面的代码演示里根据变量 `score` 的值所在的范围分别返回 `int` 数字 `3`、`2`、`1` 或 `0`。

### 条件表达式的作用域

XiaoXuan Lang IR 规定条件表达式里的 3 个子表达式都应该有各自的作用域，也就是说，如果要在 3 个子表达式里创建局部变量，应该限制这些局部变量仅仅在条件控制表达式内有效，而不能影响表达式以外的作用域。

如果在条件表达式的任一个子表达式里直接写 `let` 表达式，会被拒绝解析或编译。

示例：

```clojure
(if (let i 100)  ;; 这句会被拒绝编译
    (...)
    (...)
)
```

```clojure
(if (eq x 100)
    (let i 100)  ;; 这句会被拒绝编译
    (...)
)
```

```clojure
(if (eq x 100)
    (...)
    (let i 100)  ;; 这句会被拒绝编译
)
```

如果需要在条件表达式里创建局部变量，需要写在 `do` 表达式里，示例：

```clojure
(if (eq x 100)
    (do
        (let i 100)
        ...
    )
)
```

如果要创建对整个条件表达式使用的局部变量，可以把 `if` 表达式写在一个 `do` 表达式里，示例：

```clojure
(do
    (let i 100)
    (if
        ...
    )
)
```

## 循环控制表达式

使用循环表达式可以让目标表达式重复执行。循环表达式一共由 3 个 `关联表达式` 完成，分别是：

1. `loop` 表达式用于定义循环变量及其初始值；
2. `break` 表达式用于中断循环并返回指定的值；
3. `recur` 表达式用于更新循环变量的值并再次执行目标表达式。

其中 `loop` 子表达式的语法是：

`(loop (param1 param2 ...) (init_value1 init_value2 ...) target_exp)`

其中第一个子表达式是循环变量列表（所谓 `循环变量` 是指在每次循环里，其值有可能不同，但同名标识符，相当于函数的形参），第二个子表达式是循环变量的初始值列表，第三个参数是被执行的目标表达式。

目标表达式最后需要返回一个列表:

- 如果返回的列表有两个元素，其中第一个元素的值为 `int` 数字 `0`，比如 `(0 123)`，则表示中止循环，并把第二个元素 `123` 作为整个循环表达式的值。
- 如果返回的列表有一个或多个元素，其中第一个元素的值为 `int` 数字 `1`，比如 `(1 77 88)`，则表示用第一个元素之外的其余元素重新传入 `loop` 表达式的循环变量，然后再执行一次目标表达式。

在语法上，XiaoXuan Lang IR 约定必须使用 `break` 或者 `recur` 表达式构造目标表达式的返回值，实际上 `(break 123)` 就是返回 `(0 123)`，而 `(recur 77 88)` 就是返回列表 `(1 77 88)`。

需注意：

- `break` 和 `recur` 表达式必须位于目标表达式（块）的最后一句；
- 如果目标表达式里面包含有分支，则必须保证每个分支的最后一句必须是 `break` 或者 `recur` 表达式。

示例：

```clojure
(loop (count current) (10 1)
    (if (gt current count)
        (break count)
        (recur (add count current) (add current 1))
    )
)
```

上面示例代码实现了让 `current` 变量从数字 `1` 增长到 `11`，变量 `count` 每次循环都加上变量 `current` 的值，直到第 10 次之后中止循环。即程序实现了 \(1 + 2 + 3 + .. + 10 = 55\)，最后返回变量 `count` 的值，即数字 `55`。

注意，如果循环变量里有用户自定义数据类型，需要遵循一定的调用规则，详细见 [用户自定义数据及内存管理](user-defined-data-and-memory-management.md)。

## 用户自定义函数表达式

使用用户自定义函数表达式 `defn` 表达式可以创建一个用户自定义函数，格式如下：

`(defn function_name:return_data_type (param1:data_type param2:data_type ... paramN:data_type) function_body)`

`defn` 表达式的第 2 个子表达式是参数名列表，如果函数没有参数，需要写上一对空括号 `()`，表达式的第 3 个子表达式是函数的主体，主体可以是一个字面量、标识符或者另外一个表达式。

示例：

```clojure
(defn double:i64 (x:i64) (mul x 2))
```

如果函数主体是一个块表达式，则最后一条表达式的值会作为函数的值返回。显然所有函数都会有一个返回值，对于确实无意义返回值的函数，约定返回 `int` 类型的 `0`。

参数的默认数据类型是 `i64`，如果需要指定参数的数据类型，需要在参数名称后面加上 `:type_name` 后缀。函数的返回值数据类型编译器一般能自动推导，当然也可以手动指定返回值的数据类型，方法是在函数的名称后面加上 `:type_name` 后缀。

> 一般 **不建议** 省略参数和返回值的数据类型

### 元组

在 XiaoXuan Lang IR 里，用户自定义函数可以赋值给另外一个标识符，也可以作为参数传给另外一个函数，比如：

```clojure
;; 定义一个名为 `apply` 的用户自定义函数，函数有两个参数，
;; 第一个参数用于传入一个函数，第二个参数用于传入一个操作数。
;; 函数的主体是使用传入的函数应用到操作数，并返回结果。
(defn apply:i64 ([!func:int *closure:ptr] num)
    (call !func num 2 *closure)
)

(apply add 10) ;; 将 add 函数传入 apply 函数，返回结果 12
(apply mul 10) ;; 将 mul 函数传入 apply 函数，返回结果 20
```

注：XiaoXuan Lang IR 不支持类似常见编程语言当中的 `return` 语句，即无法中途返回一个值，但使用条件控制结构可以实现相同的目的。

### 递归调用的函数

如果要构建一个需要递归调用的用户自定义函数，可以使用 `defnr` 表达式。使用 `defnr` 表达式构建的函数会进行尾部调用优化（Tail call optimization），以防止运行时创建过多的调用栈。

`defnr` 表达式跟 `loop` 表达式非常相似，详细规则见 [循环控制表达式](#循环控制表达式)

示例：

```clojure
(defnr sum (current end acc)
    (if (gt current end)
        (break acc)
        (do
            (let next (add current 1))
            (let sum (add acc current))
            (recur next end sum)
        )
    )
)
```

上面的示例演示了一个从整数 `start` 累加到 `end` 的程序，比如 `(sum 1 100 0)` 会返回 `5050`。

### 匿名函数

匿名函数即在用户自定义函数里定义的函数，有些编程语言也称为 `Lambda`，跟用户自定义函数一样，匿名函数可以赋值到一个变量，也可以可以作为参数传给另外一个函数。不同的是，匿名函数还会捕获其所在环境（Environment）的标识符的值，并有自己的环境。

匿名函数使用 `fn` 表达式定义，`fn` 表达式格式如下。

```clojure
(fn (param1 param2 ... paramN)
    (primitive_identifier1 primitive_identifier2 ... primitive_identifierN)
    (udt_identifier1 udt_identifier2 ... udt_identifierN)
    function_body
)
```

`fn` 表达式的第一个子表达式是参数列表；第二个子表达式是需捕获的基本数据类型的标识符的名称列表，如果没有则留空；第三个子表达式是需捕获的用户自定义数据类型的标识符的名称列表，如果没有则留空；最后一个子表达式是匿名函数的主体。

示例：

```clojure
(defn inc (level)
    (fn (num)
        (level)
        ()
        (add level num)
    )
)
```

上面示例代码定义了一个名为 `inc` 的用户自定义函数，调用它后会传回一个匿名函数，该匿名函数捕获了环境标识符 `level`，所以 `fn` 表达式的第二个表达式是 `(level)`。应用示例：

```clojure
(do
    (let incTwo (inc 2))
    (let incTen (inc 10))
    (incTwo 2) ;; 返回 2+2=4
    (incTwo 6) ;; 返回 2+6=8
    (incTen 2) ;; 返回 10+2=12
    (incTen 6) ;; 返回 10+6=16
)
```

之所以需要将基本类型的标识符和用户自定义数据类型的标识符分别列出，是因为基本类型标识符的值只需简单复制到匿名函数自己的环境，而用户自定义数据类型的标识符，则在捕获时需要增加其引用计数值。并且需要绑定了匿名函数的标识符超出作用域时减少它们的引用计数值。详细请见 [用户自定义数据及内存管理](user-defined-data-and-memory-management.md)。

## 注释

XiaoXuan Lang IR 支持单行注释，以分号 `;` 开始，直到句尾。注释的内容会被编译器忽略。

示例：

```clojure
; 这是一行注释
(let i 123) ; 从这里开始一直到行尾都是注释
```

## 标注

在表达式开始符号 `(` 前面添加 `@` 符号表示给该表达式添加标注，这些标注一般是给编译器使用的，比如标注 XiaoXuan Lang IR 代码对应的 XiaoXuan Lang 源码的位置信息等，示例：

```clojure
(namespace foo
    @source_map:line=12,column=4(defn test () (...))
)
```

## 语言约束

XiaoXuan Lang IR 有一些语言级别的约束，如果没有满足这些约束，编译器会拒绝编译：

1. 函数求值表达式里不能嵌套其他表达式。

1. 前面章节已讲述的约束，比如：`loop` 表达式的最后一句必须是 `break` 或者 `recur`；标识符不能名称冲突等。

2. `if` 表达式里的 3 个子表达式均不能直接写 `let` 表达式，如果需要创建局部变量，可以构建一个 `do` 表达式，然后在里面写 `let` 表达式。详细见 [条件表达式的作用域](#条件表达式的作用域)。

3. 函数的参数不能直接传入 `::new(...)` 以及 `::new$N(...)` 之类的对象构造函数，需要使用 `let` 表达式接收此类构造函数生成的对象，然后再把它作为值传递给其他函数。对于前端语言里直接在参数里传入新构造对象的语句，可以解析为使用 `do` 把调用函数的语句包围起来。比如：

```clojure
(do
    (let a (x::new ...))
    (let b (y::new ...))
    (func a b)
)
```

4. 匿名函数不能在定义的同时直接调用，需要使用 `let` 表达式接收其值，然后再调用它或者把它作为值传递给其他函数。

上面的后 3 条约束皆与 XiaoXuan Lang IR 的资源回收工作方式有关，详细请见 [用户自定义数据及内存管理](user-defined-data-and-memory-management.md)。