# 内存管理

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [内存管理](#内存管理)
  - [内存空间分配](#内存空间分配)
  - [对象的访问](#对象的访问)
    - [分配对象的内存空间](#分配对象的内存空间)
    - [读写成员值](#读写成员值)
    - [非托管内存](#非托管内存)
  - [资源回收](#资源回收)
    - [修改对象的引用计数](#修改对象的引用计数)
    - [对象的访问模式](#对象的访问模式)
      - [let 表达式](#let-表达式)
      - [loop 表达式](#loop-表达式)
      - [匿名函数](#匿名函数)

<!-- /code_chunk_output -->

## 内存空间分配

## 对象的访问

IR 提供一些内置的函数来构建和读写对象。

### 分配对象的内存空间

函数分布在 `builtin.memory`。

- `int create_bytes(i32 bytes_length)`

  创建一个 `字节数组` 类型的对象，内存的内容初始化为 `0`，函数返回该对象在内存中的地址。

- `int create_struct(i32 bytes_length， i32 mark)`

  创建一个 `多成员结构体` 类型的对象，其中 `mark` 为各个成员的是否对象类型的标记。

- `int create_struct_destructor(i32 bytes_length， i32 mark, int destructor_addr)`

  创建一个带 `析构函数` 的 `多成员结构体` 对象，`destructor_addr 是析构函数的地址。

### 读写成员值

- `i32 read_i32(int addr, i32 byte_offset)`
- `i64 read_i64(int addr, i32 byte_offset)`
- `f32 read_f32(int addr, i32 byte_offset)`
- `f64 read_f64(int addr, i32 byte_offset)`
- `i32 write_i32(int addr, i32 byte_offset, i32 val)`
- `i64 write_i64(int addr, i32 byte_offset, i64 val)`
- `i32 write_f32(int addr, i32 byte_offset, f32 val)`
- `f64 write_f64(int addr, i32 byte_offset, f64 val)`

上述函数中，`addr` 参数是目标对象的内存地址，`byte_offset` 是结构体数据段地址开始的字节偏移量。对于 `多成员结构体` 的对象来说，因为每个成员都占用 8 bytes，所以 `byte_offset` 应该是 8 的整数倍，即 `成员的索引 * 8`。

- `int read_address(int addr, i32 byte_offset)`

  获取指定成员的地址值。实际上是对 read_i32 和 read_i64 的封装，由编译器自动选择。

### 非托管内存

- `malloc(int size_bytes)`

  分配一段非托管的内存空间

- `free(int addr)`

  释放非托管的内存空间

- `memcpy(int target, int source, int size_bytes)`

  复制非托管内存空间的数据

## 资源回收

考虑到 Lang 不会出现对象的循环引用，为了简单起见这里使用 `引用计数法` 举例 Lang 的资源回收相关函数及方法。

如果要完全实现 `资源回收器`，大致上还应该维护一个废弃对象（garbage）的链表，还要对 `堆` 按照对象的成员数量的不同而分割成多个块，以提高分配新对象的速度。比如 1 个成员的对象归在一个块，2 个成员的对象归在一个块，数组长度在 32 bytes 之内的归在一个块，数组长度在 128 bytes 之内的归在一个块等等。因为资源回收的内容不属于 IR 的规范范围，这里不进一步展开。

需注意的是，这里描述的资源回收方法，以及本地结构体的实现方法都只是为了方面描述而提供的一种参考，解析器或编译器可以实现自己的资源回收。


### 修改对象的引用计数

- `i32 inc_ref(int addr)`

  增加对象引用计数值，返回更新后的引用计数值。
  当将一个对象赋值给另外一个变量时需要调用这个函数以增加引用计数。

  新建对象的默认引用计数值为 0，所以 Lang 的一条 `let` 语句，实际上在 IR 里调用了 `create_struct` （或 `create_bytes`）以及 `inc_ref` 一共 2 个函数共同完成。

- `i32 add_ref(int addr, i32 byte_offset, int ref_addr)`

  将 "被引用的对象" 的地址写入到指定对象的指定成员，并增加 "被引用的对象" 的引用计数值，返回 "被引用的对象" 更新后的引用计数值。

  注意在创建具有多层结构的对象（即包含 `子对象` 的对象）时，在内层的对象创建之后，不需要单独调用 `inc_ref` 函数增加其计数值，而应该使用 `add_ref` 将内层对象链接到到外层对象。

- `i32 dec_ref(int addr)`

  减少结构体的引用计数值，返回更新后的引用计数值。

  当一个用户自定义数据类型的变量生命周期结束后（即指令运行到变量有效范围的最后一行），需调用这个方法以减少对象的引用计数值。当一个对象引用计数为 0 时，会遍历其所有引用的对象（即 `子对象`），然后把它们的引用计数值都减少 1，最后这个对象的资源会被回收。

### 对象的访问模式

为了能让资源回收正常工作，或者说为了准确地统计对象的引用计数值，IR 在访问对象时，有一些固定的模式，编译到 IR 时需要遵循这些模式。

这些模式的原理是，当一个对象被另一个对象引用或者被一个标识符引用时，要保证其引用计数值增加了 1，如果一个引用对象的标识符将要离开其作用域，则要保证其引用计数值减少了 1。

具体的实现有这些：

#### let 表达式

`let` 表达式里的值子表达式如果是调用 `::new(...)` 以及 `::new$N(...)` 之类的对象构造函数，或者直接返回这类构造函数的值，需要紧接着调用 `builtin.memory.inc_ref()` 函数以增加对象的引用计数值。（但在 `::new(...)` 以及 `::new$N(...)` 的函数本身里，对于要返回的对象，则不能调用 `inc_ref`，应该留给构造函数调用者调用）。

当 `let` 表达式创建的标识符离开作用域时，必须调用 `builtin.memory.dec_ref()` 函数以减少对象的引用计数值。即 `inc_ref()` 和 `dec_ref()` 总是成对出现的。

<!--
::NOTE 从第一章挪过来的内容 ::

将一个局部变量的值赋值给另外一个局部变量的具体过程如下：

- 如果值为基本数据类型，则值会被直接复制；
- 如果值为用户自定义类型（或者是元组里包含有用户自定义类型），因为所有用户自定义类型的数据都存储在堆里，局部变量的值实际上是数据的指针（即数据在内存中的地址），所以在复制此类局部变量时，目标数据是托管数据（即受资源回收器管理的数据），则还需还需要手动增加目标数据的引用计数值，当程序执行到标识符的作用范围之外时，需要手动减少目标数据的引用计数值。

- 如果为用户自定义函数，标识符的值实际上是一个元组，包含函数的指针和一个闭包的指针，函数的指针和函数类型会直接复制，而闭包的指针（如果值不为 0）跟用户自定义类型一样处理。
- 如果标识符是动态数据类型，标识符的值实际上是一个元组，包含数据的实际类型和一个数据的值或指针。

有关增加和减少引用计数值的详细内容，请见 [用户自定义数据和内存管理](user-defined-data-and-memory-management.md) 一章。

-->

#### loop 表达式

`loop` 表达式里比较特殊，如果 `loop` 表达式的循环参数里有用户自定义类型，需要在 `loop` 表达式之前使用 `inc_ref` 以增加它们的引用计数值，然后在 `loop` 表达式主体的倒数第二句（即，在最后一句 `break` 或者 `recur` 之前）使用 `dec_ref` 以减少它们的引用计数值。

这是因为，`loop` 表达式的循环变量在每次循环时（除了第一次循环）都会（在 `recur` 表达式之前）创建了一个新的对象然后再代入该循环变量参数。

#### 匿名函数

因为匿名函数会捕获当前环境的变量，包括用户自定义类型的变量，而这些变量应该保证在匿名函数（或者说，绑定了匿名函数的变量）的生命周期之内都有效，所以会看到匿名函数表达式的参数略多。不过匿名函数所捕获的用户自定义类型的对象会由运行时自动调用 `inc_ref`，也会在匿名函数生命周期结束之后自动调用 `dec_ref`。

匿名函数本身也会产生一个对象，这个对象的成员就是它所捕获的变量，然后绑定了匿名函数的变量也跟普通 `多成员结构体` 对象一样，需要遵循同样的访问模式。
