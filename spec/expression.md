# 表达式

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [表达式](#表达式)
  - [数据类型](#数据类型)
  - [基本语法](#基本语法)
  - [组织表达式](#组织表达式)
    - [赋值表达式](#赋值表达式)
      - [](#)
    - [命名空间和上下文](#命名空间和上下文)
      - [层次型命名空间](#层次型命名空间)

<!-- /code_chunk_output -->

## 数据类型

XiaoXuan IR 只支持 `i32`, `i64`, `f32` 和 `f64` 四种数据类型。在 XiaoXuan IR 源码里可以使用数字字面量表示这 4 种数据类型，如果数字字面量的格式是 `[\+\-]?[0-9]+`，则会被解析为整型，如果数字字面量还包含有小数点或者字符 `e` 则会解析为浮点型，默认整型是 `i64`，默认浮点型是 `f64`。示例：

* i64: `123`, `-1`, `0`, `-456`
* f64: `2.718`, `6.626e-34`，`-1.23`，`3.0`

如果要表示 `i32` 和 `f32`，需要在字面量后面加上 `s` 字符后缀，示例：

* i32: `123s`，`-456s`
* f32: `3.14s`, `-4.56s`, `4.0s`

XiaoXuan IR 还支持 `int` 数据类型，它是 `i32` 或者 `i64` 的别名，编译器会根据机器环境自动转换，`int` 类型常常用来表示内存地址、函数索引、结构体（用户自定义类型）索引、结构体成员的索引。

## 基本语法

XiaoXuan IR 源码由 [S-表达式](https://en.wikipedia.org/wiki/S-expression) 组成，表达式由一对圆括号里面填上由空格分开的函数名称及参数组成。

语法：

`(function-name arg1 arg2 ... argN)`

每个表达式可视作一次函数调用，其中 `function-name` 是函数名称，`arg1`、`arg2` 和 `argN` 是参数，每个表达式 "必须" 有返回值，对于无意义返回值的表达值，约定返回整数（即 i64 类型） `0`。

表达式可以嵌套，比如：

```clojure
(root (add (square 3) (square 4)))
```

上面代码相当于函数：

\[
    \sqrt{3^2 + 4^2}
\]

运行时，表达式会依次从最外层开始求值（"求值" 也就是调用函数并获取其返回值），但遇到参数是另外一个表达式时，需要先内层表达式求值才能作为参数值对外层表达式求值，所以实际上最内层的表达式会最先被执行。

一个源文件可以有一个或多个表达式，也就是说一个程序本质是一系列函数的调用。

表达式可以大致分为 3 类：

* 内置函数
  内置函数对应着机器指令或者机器指令的简单组合，如整数相加、位运算 "或" 等。
* 组织表达式
  用于组织代码的表达式，比如赋值表达式、条件表达式，组织表达式相当于一般高级语言的 "关键字"。
* 用户自定义函数
  实现一定功能的代码块，一般是将内置函数、组织表达式以及其他自定义函数按照逻辑组合在一起而形成。

## 组织表达式

### 赋值表达式

赋值表达式用于创建一个在当前环境（Environment）有效的变量（局部变量）。

语法：

`(let variable-name value)`

其中的值可以是 IR 支持的基本数据类型的字面量，示例：

```clojure
(let i 123)
(let j 3.14s)
```

赋值表达式的（返回）值就是表达式内的那个值，所以上面的第一行表达式创建了一个名称为 `i` 的变量，其值为 `i64` 类型的 `123`。

因为每个表达式也有返回值，所以 表达式里的值也可以是另一个表达式，示例：

```clojure
(let i (let j 123))
```

又因为表达式返回值的数据类型以及字面量的数据类型是确定的，所以赋值时并不需要指定变量的数据类型，编译器会自动推断。

> 变量一旦创建（在创建的同时被赋值）之后，其值不能再改变。

#### 变量的引用

当将一个变量赋值给另外一个变量时，比如：

```clojure
(let i 123)
(let j i)
```

* 如果一个变量的值为基本数据类型，则值会被复制；
* 如果变量的值为用户自定义类型，因为所有用户自定义类型的数据都存储在堆里，变量的值实际上是内存的指针，所以在复制变量的值（即指针）时，还会同时增加目标数据的引用计数值，当程序执行到变量的作用范围之外时，变量会被销毁，变量所指的目标数据的引用计数值会相应地减少。

### 命名空间和上下文

XiaoXuan IR 程序是由一堆（用户自定义）函数组成，`namespace` 用于将相关的函数划分为不同的 "小组"，每个 "小组" 称为一个命名空间（namespace），每个命名空间里平铺列出一个或多个常量和函数表达式。

示例：

```clojure
(namespace foo
    (const PI 3.14)
    (defn inc (i) (add i 1))
    (defn dec (i) (sub i 1))
)
```

上面代码当中的 `foo` 是命名空间的名称，里面的 3 个表达式分别表示定义了一个常量及两个函数。

每个命名空间都有（且只有）一个上下文（context，可以想象为一个散列 Map），用户自定义函数及常量以平铺的形式存储在命名空间上下文里。上面的示例所构造的上下文对象如下：

```js
{
    "PI": 3.14,
    "inc": Function(...),
    "dec:" Function(...)
}
```

#### 层次型命名空间

命名空间可以嵌套，形成有层次的结构。

示例：

```js
(namespace foo
    (const A 123)
    (namespace bar
        (const B 456)
        (const C 789)
    )
)
```

上面的代码构建了两个命名空间 `foo` 和 `bar`，其中 `bar` 位于 `foo` 命名空间之内。

虽然命名空间在组织上有层次关系，但在逻辑功能上，每个命名空间是同级平行的。也就是说，子命名空间并不会自动继承父命名空间的常量或者函数。