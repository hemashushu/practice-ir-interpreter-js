# 表达式

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [表达式](#表达式)
  - [基本数据类型](#基本数据类型)
    - [`int` 数据类型](#int-数据类型)
  - [基本语法](#基本语法)
    - [结构表达式](#结构表达式)
    - [函数](#函数)
  - [XiaoXuan Lang IR 源码的结构](#xiaoxuan-lang-ir-源码的结构)
  - [REPL 模式](#repl-模式)
  - [命名空间表达式](#命名空间表达式)
    - [层次型命名空间](#层次型命名空间)
    - [根命名空间](#根命名空间)
    - [访问不同模块里的标识符](#访问不同模块里的标识符)
    - [访问同一个模块同一个命名空间里的标识符](#访问同一个模块同一个命名空间里的标识符)
    - [访问同一个模块但不同命名空间里的标识符](#访问同一个模块但不同命名空间里的标识符)
  - [表达式块](#表达式块)
    - [作用域](#作用域)
      - [标识符名称冲突](#标识符名称冲突)
  - [常量表达式](#常量表达式)
    - [用户自定义数据类型的常量](#用户自定义数据类型的常量)
  - [变量表达式](#变量表达式)
    - [值的不变性和复制](#值的不变性和复制)
  - [赋值表达式](#赋值表达式)
  - [条件控制表达式](#条件控制表达式)
    - [条件表达式的作用域](#条件表达式的作用域)
  - [循环控制表达式](#循环控制表达式)
  - [用户自定义函数表达式](#用户自定义函数表达式)
    - [递归调用的函数](#递归调用的函数)
    - [匿名函数](#匿名函数)
  - [注释](#注释)
  - [标注](#标注)
  - [语言约束](#语言约束)

<!-- /code_chunk_output -->

XiaoXuan Lang IR 是将 XiaoXuan Lang 程序编译成目标程序（本地代码或者 WASM 字节码）过程中的中间代码，它是对常见的机器指令的简单抽象和封装。XiaoXuan Lang IR 并不是直接面向用户（程序员）的编程语言，也不是 LISP 方言。

## 基本数据类型

XiaoXuan Lang IR 只支持 `i32`, `i64`, `f32` 和 `f64` 四种基本数据类型（Primitive data type）。在 XiaoXuan Lang IR 源码里可以直接表示这 4 种数据类型的字面量：

- 格式 `[\+\-]?[0-9]+` 会被解析为整型 `i64`；
- 如果数字字面量还包含有小数点或者字符 `e` 则会解析为浮点型 `f64`。

示例：

- i64: `123`, `-1`, `0`, `-456`
- f64: `2.718`, `6.626e-34`，`-1.23`，`3.0`

如果要表示 `i32` 和 `f32`，需要在字面量后面加上 `s` 字符后缀。

示例：

- i32: `123s`，`-456s`
- f32: `3.14s`, `-4.56s`, `4.0s`

XiaoXuan Lang IR 所有函数和表达式的运算结果只能是这几种数据类型。

### `int` 数据类型

XiaoXuan Lang IR 还支持名为 `int` 的数据类型，它是 `i32` 或 `i64` 的别名，编译器会根据目标机器环境自动选择它们其中之一，`int` 类型用于表示内存地址、函数地址、以及用户自定义数据的地址。

## 基本语法

XiaoXuan Lang IR 源码由 [S-表达式](https://en.wikipedia.org/wiki/S-expression) 组成，`S-表达式` 由一对圆括号里面包含一个或多个由空格分开的 `符号`（`Symbol`，即连续的一串字符、数字和标点符号）组成。

格式：

`(symbol1 symbol2 ... symbolN)`

XiaoXuan Lang IR 表达式大致可以分为 2 类：结构表达式和函数表达式。

### 结构表达式

结构表达式用于组织源码，相当于一般高级语言里的 `关键字`。XiaoXuan Lang IR 的结构表达式有：

- `namespace` 命名空间定义
- `do` 表达式块
- `const` 常量定义
- `let` 变量定义
- `set` 变量赋值
- `if` 条件控制
- `loop`、`break` 和 `recur` 循环控制
- `defn`、`defnr` 和 `fn` 函数定义

结构表达式的格式：

`(name sub-exp1 sub-exp2 ... sub-expN)`

表达式的第一个部分是结构的名称，其余部分是 `子表达式`。

`子表达式` 可以是另外一个结构表达式，表达式可以嵌套。`子表达式` 也可以是函数表达式，甚至还可以是基本数据类型的字面量或者 `标识符`（`identifier`，即函数、常量、变量的名称）。

示例：

```clojure
(if
    (ge x 60)
    (if
        (ge x 80)
        (add x 10)
        x
    )
    0
)
```

上例是一个 `if` 结构表达式，`if` 表达式规定需要有 3 个子表达式组成。在上例中：

- 第一个子表达式是函数表达式 `(ge x 60)`；
- 第二个子表达式是另外一个 `if` 表达式；
- 第三个子表达式是字面量 `0`。

结构表达式里的各个子表达式并不一定都会被执行，比如上例中的 `if` 表达式，当条件 `(ge x 60)` 成立时，会执行第二个子表达式，不成立时，则会执行第三个子表达式。

### 函数

函数表达式的格式是：

`(function-name arg1 arg2 ... argN)`

表达式的第一个部分是函数的名称，其余的部分是函数的参数。参数既可以是基本数据类型的字面量，也可以是标识符，还可以是一个表达式。对于作为参数的表达式，称为 `参数表达式`。

每条函数表达式可视作一次 `函数调用`（也称为 `对表达式求值`），调用函数时，会先对各个 `参数表达式` 进行求值，然后将各个 `参数表达式` 的返回值作为参数值（即实参）来调用函数，最后返回函数的运算结果。

规定每个函数 **必须** 有返回值，对于确实不具备返回意义的表达值，约定返回 `int` 类型的数字 `0`。

示例：

```clojure
(sqrt (add (square 3) (square 4)))
```

上面代码相当于函数：

\[
\sqrt{3^2 + 4^2}
\]

函数大致可以分为：`本地函数`、`内置函数` 和 `用户自定义函数`。

- 本地函数

  本地函数对应着机器指令，如整数的乘除加减运算、整数的位运算等。

- 内置函数

  内置函数是运行时（runtime）所必须的基础功能，类似系统调用，比如分配内存等。

- 用户自定义函数

  用户自定义函数跟本地/内置函数类似，不同的是这些函数是用户（程序员）产生的。

  用户自定义函数由本地函数、内置函数、其他用户自定义函数以及结构表达式，按照一定的逻辑和功能要求组合而成。一个应用程序的源码实际上就是一堆用户自定义函数。

## XiaoXuan Lang IR 源码的结构

一个 XiaoXuan Lang IR 源文件最顶层只允许一个或并列多个 `namespace` 表达式，在 `namespace` 表达式内只允许并列一个或多个 `const`，`defn` 和 `defnr` 这 3 种表达式。

示例：

```clojure
(namespace ns1
    (const ...)
    (defn ...)
    (defnr ...)
    ...
)

(namespace ns2
    ...
)
```

## REPL 模式

REPL 模式用于学习和调试 XiaoXuan Lang IR 解析器或编译器。在 REPL 模式下，默认在名为 `user` 的命名空间中，每一条表达式会立即被执行，但不支持直接执行 `let` 和 `set` 表达式，它们必须写在 `do` 表达式或者函数表达式里。

在 REPL 模式下，也可以直接输入字面量或者标识符，字面量和标识符的值会被输出。

## 命名空间表达式

XiaoXuan Lang IR 程序由一堆并列的用户自定义函数和常量组成，当一个程序规模较大时，所有函数堆在一起会比较难以维护。所以 XiaoXuan Lang IR 引入了一个叫做 `命名空间`（`namespace`）的概念，将函数按照相关性划分为一个一个的 `小组`，每个 `小组` 就是一个 `命名空间`。

示例：

```clojure
(namespace foo
    (const PI 3.14)
    (defn inc (i) (add i 1))
    (defn dec (i) (sub i 1))
)
```

上面代码当中的 `foo` 是命名空间的名称，里面定义了一个常量及两个用户自定义函数。

在一个模块（在其他编程语言里也叫做 `包`，`package`）里，一个命名空间的代码不必一次过全部写完，可以分布到多个 `namespace` 表达式里，甚至可以分布到多个源代码文件，只要名称相同即可，编译器会把它们合并成同一个命名空间。示例：

```clojure
(namespace foo
    (const PI 3.14)
)

(namespace foo
    (defn inc (i) (add i 1))
    (defn dec (i) (sub i 1))
)
```

上面的代码在编译时会被分别编译，但最后会合并为同一个命名空间 `foo`。

当然，如果模块不同，即使名称相同，命名空间也是不同的。

一个应用程序在运行时有（且只有）一个 `全局表`（`Global table`，可以想象为一个散列 Map），所有用户自定义函数及常量以平铺的形式存储在里面。

每项存储内容的名称格式为：

`模块名称` + `.` + `命名空间名称` + `.` + `用户自定义函数或常量的名称`

这种名称也叫做标识符的全称 `Full name`。

假设上面的示例代码位于一个叫做 `mylib` 的模块里，则全局表内容（用 JavaScript 对象表示）如下：

```js
{
    "mylib.foo.PI": 3.14,
    "mylib.foo.inc": Function(...),
    "mylib.foo.dec:" Function(...)
}
```

可见对于 XiaoXuan Lang IR 来说，命名空间只是一个概念，最后它仅仅是成为标识符的名称前缀而已。

注： `namespace` 表达式是用于组织代码的特殊表达式，表达式没有返回值。当编译目标为本地代码时，也不存在上述的 `全局表`，取而代之的可能是 `函数表` 和 `数据段`。

### 层次型命名空间

在给一个命名空间命名时，可以为它加上其他命名空间的名称作为前缀，以表示当前命名空间是目标命名空间下面的一个细分。名称和名称之间使用点号 `.` 分隔。

示例：

```clojure
(namespace foo
    (const A 123)
)

(namespace foo.bar
    (const B 456)
)

(namespace foo.bar.one
    (const C 789)
)
```

假设上面的示例代码位于一个叫做 `mylib` 的模块里，则它们构建了 3 个命名空间 `mylib.foo`、`mylib.foo.bar` 和 `mylib.foo.bar.one`。这种通过将多个命名空间名称连接起来的名称也叫做 `命名空间路径`。

虽然层次型命名空间对 XiaoXuan Lang IR 并没多大意义，但对于上层语言————比如 XiaoXuan Lang 来说却有重大意义，比如可以将相关功能更细致地分组，可以更好地组织源代码，可以保护内部方法不被外部访问等。因此上层语言编译成 XiaoXuan Lang IR 时，通常会存在多层命名空间。

### 根命名空间

跟当前模块的名称同名的命名空间，被称为 `根命名空间`。如果想把用户自定义函数或者常量定义在一个模块的根命名空间里，则需要传参数 `()` （即一对空括号） 给 `namespace` 表达式的第一个参数。

示例：

```clojure
(namespace ()
    (const X 100)
)
```

假设上面的示例代码位于一个叫做 `mylib` 的模块里，则常量 `X` 完整名称为 `mylib.X`。

### 访问不同模块里的标识符

在一个模块里想访问另一个模块里的标识符，需要把这个标识符的完整名称写出来。比如现在有一个叫做 `example` 模块，想访问上例当中的常量 `B`，则代码如下：

```clojure
(namespace ()
    (defn main () (do
        (let i mylib.foo.B)
    ))
)
```

### 访问同一个模块同一个命名空间里的标识符

在同一个模块的同一个命名空间里，访问标识符只需单独书写标识符的名称即可，比如：

```clojure
(namespce foo
    (const A 1)
    (defn inc (i) (add A i))
    (defn incAndDouble (i) (mul (inc i) 2))
)
```

在上面的代码中，函数 `inc` 引用常量 `A`，只需直接书写这个常量的名称；同样在函数 `incAndDouble` 里引用了函数 `inc` 只需直接书写这个函数名称即可。

### 访问同一个模块但不同命名空间里的标识符

在同一个模块里，如果要访问不同的命名空间里的标识符，跟访问不同模块的标识符情况一下，需要写上标识符的完整名称。

假设当前模块的名称为 `mylib`，上面代码创建了一个命名空间 `foo`，现在有另外一个命名空间 `foo.bar`，如果想访问 `foo` 命名空间里面的常量 `A`，则代码如下：

```clojure
(namespace foo.bar
    (defn hello () (
        (let i mylib.foo.A))
    ))
)
```

## 表达式块

使用块表达式（`do` 表达式）可以将多个表达式组成一个 `表达式块`，在执行时，表达式块里的表达式将依次被执行，最后一个表达式（或者标识符、字面量）的值将会作为表达式块的值被返回。

示例：

```clojure
(do
    (let a 10)
    (let b 20)
    (add a b)
)
```

上面代码创建了一个表达式块，里面有 3 个表达式，先执行变量 `a` 和变量 `b` 的定义表达式，然后执行表达式 `(add a b)` 将两个变量的值相加，最后相加的结果作为表达式块的值返回。

因为最后一个表达式返回值的数据类型是确定的，所以块表达式不需要指定返回值的数据类型，编译器会自动推断。

### 作用域

块表达式同时还会创建一个独立的 `作用域`。作用域就是标识符的有效范围，作用域的结构可以是并列的，示例：

```clojure
(do
    ;; 作用域 A
)
(do
    ;; 作用域 B
)
```

在上面的示例代码中，两个 `do` 表达式分别创建了两个作用域 `作用域 A` 和 `作用域 B`，位于这两个作用域之内的标识符完全不相干。并列作用域起到了有效范围的 "隔离" 效果。

示例：

```clojure
(do
    (let a 10)
)
(do
    ;; 这里无法访问 `a`
)
```

作用域也可以是层次型的，示例：

```clojure
(do
    ;; 作用域 A
    (do
        ;; 作用域 B
    )
    ;; 作用域 A
)
```

对于层次型的作用域，处于外层作用域的标识符的有效范围会覆盖到内层作用域，在上面的示例代码中，`作用域 A` 的有效范围会覆盖 `作用域 B`。也就是说在 `作用域 B` 里能直接访问 `作用域 A` 里的所有标识符（当然要求是在第 2 个 `do` 表达式之前就已经定义的标识符）。但反过来，在 `作用域 A` 里无法访问 `作用域 B` 里面的标识符。

```clojure
(do
    (let a 10)
    (do
        (let b 20)
        ;; 这里可以访问 `a`
        ;; 这里没法访问 `c`
    )
    (let c 30)
    ;; 这里可以访问 `a`
    ;; 这里无法访问 `b`
)
```

#### 标识符名称冲突

XiaoXuan Lang IR 不允许在标识符（包括 `常量`、`用户自定义函数`、`局部变量` 在内的所有标识符）的 `作用域` 内定义同名的标识符。具体来说有一下几种情况：

1. 在同一个命名空间里，不能定义同名的标识符。

示例：

```clojure
(namespace foo
    (const A 123)
    (defn A (i) (add i 2)) ;; 函数 `A` 跟常量 `A` 名称冲突
    (defn B ...)
    (defn B ...) ;; 函数 `B` 跟上一个函数 `B` 名称冲突
)
```

2. 在常量和用户自定义函数的名称的覆盖范围内不能定义同名的局部变量。

示例：

```clojure
(namespace foo
    (const ONE 1)
    (defn hello (i) (do
        (let ONE 10) ;; 局部变量 `ONE` 跟常量 `ONE` 名称冲突
    ))

    (defn world (k) (do
        (let hello 10) ;; 局部变量 `hello` 跟函数 `hello` 名称冲突
    ))
)
```

常量和用户自定义函数的作用域是整个应用程序，即是 `全局` 的，但因为它的实际全称带有前缀，其实并不会影响同名的局部变量，但为了避免歧义，XiaoXuan Lang IR 不允许在同一个命名空间里，定义跟常量和用户自定义函数同名的局部变量。

在上例中，常量 `ONE` 的名称覆盖范围是命名空间 `foo`，所以在函数 `test` 里定义同名的变量 `A` 会造成冲突。同样道理，函数 `test` 的名称覆盖范围也是命名空间 `foo`，所以不允许局部变量 `hello`。

3. 在同一个作用域里，不能定义同名的标识符。

示例：

```clojure
(do
    (let a 10)
    (do
        (let a 10)  ;; 跟上一层作用域里的 `num` 冲突
        (let b 20)
        (let c 30)
        ...
    )
    (let b 20)      ;; 不会跟上一个作用域里的 `b` 冲突
    (do
        (let c 30)  ;; 不会跟上一个作用域里的 `count` 冲突
        ...
    )
)
```

注：每个 `用户自定义函数`、`匿名函数`、`loop` 表达式，都隐含地创建了自己的作用域，另外在 `if` 表达式里，如果要创建局部变量，也会被要求创建自己的作用域。

## 常量表达式

常量表达式（`const` 表达式）用于将一个值绑定到一个标识符里。

常量表达式语法如下：

`(const variable-name value)`

示例：

```clojure
(const PI 3.14)
(const E 2.718)
```

<!-- 常量的值可以是字面量，也可以是 XiaoXuan 、自定义数据类型、函数。

如果常量的值是字面量，编译器在 `预处理阶段` 会对所有引用常量的地方作替换处理，也就是说，代码中所有引用该常量的地方会自动替换成相应的字面量。

如果常量的值为函数，实际作用跟用户自定义表达式（`defn` 表达式）一样。 -->

### 用户自定义数据类型的常量

常量的值除了可以是基本数据类型的字面量，也可以是 `用户自定义数据`，具体地说，可以是结构体的构造函数的调用（表达式）。示例：

```clojure
(const Blue (user.Color.new 2))
```

为了避免每次引用常量都执行一次构造函数，通常在程序被加载之后，常量所指向的构造函数会先被求值，求值的结果是一个数据在内存的地址，然后使用这个地址赋值给常量（标识符）。也就是说，常量表达式里的子表达式在应用程序的生命周期里只会被执行一次。

常量的标识符会被登记在 `全局表` 中，任何位置都可以访问到这个常量，而且数据的引用计数值不会改变，所以常量数据不会被资源回收。

## 变量表达式

变量表达式（`let` 表达式）用于在当前`有效范围`（Scope，也可以称为 `环境`，Environment）之内创建一个（局部）变量并赋值，或者说，将一个值绑定到一个局部的 `标识符`。

语法：

`(let variable-name value)`

其中第 2 个子表达式 `value` 用于传入待绑定的值，值可以是基本数据类型的字面量，也可以是另一个表达式，示例：

```clojure
(let i 123)
(let k (add 123 456))
```

赋值表达式会返回标识符的值，比如上面示例当中的第一个表达式返回 `i64` 类型的 `123`。

赋值表达式里的参数 `value` 还可以是一个函数，后面会讲述。

因为所有表达式返回值的数据类型以及字面量的数据类型都是确定的，所以并不需要指定标识符的数据类型，编译器会自动推断。

局部变量和常量的区别是：

- 变量表达式只能在表达式块里使用；
- 常量表达式只能在命名空间表达式的第一层里使用；

### 值的不变性和复制

一个标识符也可以赋值给另外一个标识符，示例：

```clojure
(let i 123)
(let j i)
```

将一个标识符赋值给另外一个标识符，具体过程如下：

- 如果标识符的值为基本数据类型，则值会被直接复制；
- 如果标识符的值为用户自定义类型，因为所有用户自定义类型的数据都存储在堆里（相当于其他语言的引用类型变量），标识符的值实际上是数据的指针（即数据在内存的地址），所以在复制此类标识符的值时，还会同时增加目标数据的引用计数值，当程序执行到标识符的作用范围之外时，目标数据的引用计数值会相应地减少。
- 如果标识符的值为用户自定义函数，标识符的值实际上是函数的指针，所以标识符的值也是直接被复制。
- 如果标识符的值为匿名函数，<!--因为匿名函数会闭包其所在环境的标识符，也就可能存在部分标识符是基本数据类型，部分是用户自定义类型，所以也需要管理其资源。-->匿名函数实际是一个指向本地结构体的指针，赋值时会直接赋值指针值，还会同时增加目标数据的引用计数值，当程序执行到标识符的作用范围之外时，目标数据的引用计数值会相应地减少。

有关增加和减少引用计数值的详细内容，请见 [用户自定义数据和内存管理](user-defined-data-and-memory-management.md) 一章。

## 赋值表达式

赋值表达式 （`set` 表达式）用于改变局部变量的值。

语法：

`(set variable-name value)`

::TODO 待完成

## 条件控制表达式

使用条件控制表达式（`if` 表达式）可以根据条件执行不同的分支，并返回该分支的值，条件控制表达式的语法如下：

`(if condition_exp true_exp false_exp)`

条件控制表达式有 3 个子表达式。其中子表达式 `condition_exp` 表示条件，其值只能是 `int` 类型的数字 `0` 或者 `1`，其中 `0` 表示逻辑 `false`，数字 `1` 表示逻辑 `true`。

当 `condition_exp` 的值为 `1` 时，`true_exp` 表达式会被执行并返回它的值，当 `condition_exp` 的值为 `0` 时，`false_exp` 表达式会被执行并返回它的值。

示例：

```clojure
(do
    (let score 75)
    (if (ge score 60) 1 0)
)
```

上面的代码表示当变量 `score` 的值大于等于 `60` 时，返回 `1`，否则返回 `0`。

使用嵌套 `if` 表达式可以表达复杂的逻辑，示例：

```clojure
(do
    (let score 80)
    (if (ge score 90)
        3
        (if (ge score 75)
            2
            (if (ge score 60) 1 0)
        )
    )
)
```

上面的代码演示里根据变量 `score` 的值所在的范围分别返回 `int` 数字 `3`、`2`、`1` 或 `0`。

### 条件表达式的作用域

XiaoXuan Lang IR 规定条件表达式里的 3 个子表达式都应该有各自的作用域，也就是说，如果要在 3 个子表达式里创建局部变量，应该限制这些局部变量仅仅在条件控制表达式内有效，而不能影响表达式以外的作用域。

如果在条件表达式的任一个子表达式里直接写 `let` 表达式，会被拒绝解析或编译。

示例：

```clojure
(if (let i 100)  ;; 这句会被拒绝编译
    (...)
    (...)
)
```

```clojure
(if (eq x 100)
    (let i 100)  ;; 这句会被拒绝编译
    (...)
)
```

```clojure
(if (eq x 100)
    (...)
    (let i 100)  ;; 这句会被拒绝编译
)
```

如果需要在条件表达式里创建局部变量，需要写在 `do` 表达式里，示例：

```clojure
(if (eq x 100)
    (do
        (let i 100)
        ...
    )
)
```

如果要创建对整个条件表达式使用的局部变量，可以把 `if` 表达式写在一个 `do` 表达式里，示例：

```clojure
(do
    (let i 100)
    (if
        ...
    )
)
```

## 循环控制表达式

使用循环表达式可以让目标表达式重复执行。循环表达式一共由 3 个 `关联表达式` 完成，分别是：

1. `loop` 表达式用于定义循环变量及其初始值；
2. `break` 表达式用于中断循环并返回指定的值；
3. `recur` 表达式用于更新循环变量的值并再次执行目标表达式。

其中 `loop` 子表达式的语法是：

`(loop (param1 param2 ...) (init_value1 init_value2 ...) target_exp)`

其中第一个子表达式是循环变量列表（所谓 `循环变量` 是指在每次循环里，其值有可能不同，但同名标识符，相当于函数的形参），第二个子表达式是循环变量的初始值列表，第三个参数是被执行的目标表达式。

目标表达式最后需要返回一个列表:

- 如果返回的列表有两个元素，其中第一个元素的值为 `int` 数字 `0`，比如 `(0 123)`，则表示中止循环，并把第二个元素 `123` 作为整个循环表达式的值。
- 如果返回的列表有一个或多个元素，其中第一个元素的值为 `int` 数字 `1`，比如 `(1 77 88)`，则表示用第一个元素之外的其余元素重新传入 `loop` 表达式的循环变量，然后再执行一次目标表达式。

在语法上，XiaoXuan Lang IR 约定必须使用 `break` 或者 `recur` 表达式构造目标表达式的返回值，实际上 `(break 123)` 就是返回 `(0 123)`，而 `(recur 77 88)` 就是返回列表 `(1 77 88)`。

需注意：

- `break` 和 `recur` 表达式必须位于目标表达式（块）的最后一句；
- 如果目标表达式里面包含有分支，则必须保证每个分支的最后一句必须是 `break` 或者 `recur` 表达式。

示例：

```clojure
(loop (count current) (10 1)
    (if (gt current count)
        (break count)
        (recur (add count current) (add current 1))
    )
)
```

上面示例代码实现了让 `current` 变量从数字 `1` 增长到 `11`，变量 `count` 每次循环都加上变量 `current` 的值，直到第 10 次之后中止循环。即程序实现了 \(1 + 2 + 3 + .. + 10 = 55\)，最后返回变量 `count` 的值，即数字 `55`。

注意，如果循环变量里有用户自定义数据类型，需要遵循一定的调用规则，详细见 [用户自定义数据及内存管理](user-defined-data-and-memory-management.md)。

## 用户自定义函数表达式

使用用户自定义函数表达式 `defn` 表达式可以创建一个用户自定义函数，格式如下：

`(defn function_name (param1 param2 ... paramN) function_body)`

`defn` 表达式的第 2 个子表达式是参数名列表，如果函数没有参数，需要写上一对空括号 `()`，表达式的第 3 个子表达式是函数的主体，主体可以是一个字面量、标识符或者另外一个表达式。

示例：

```clojure
(defn double (x) (mul x 2))
```

如果函数主体是一个块表达式，则最后一条表达式的值会作为函数的值返回。显然所有函数都会有一个返回值，对于确实无意义返回值的函数，约定返回 `int` 类型的 `0`。

参数的默认数据类型是 `i64`，如果需要指定参数的数据类型，需要在参数名称后面加上 `:type_name` 后缀。函数的返回值数据类型编译器一般能自动推导，当然也可以手动指定返回值的数据类型，方法是在函数的名称后面加上 `:type_name` 后缀。

示例：

```clojure
(defn double:f64
    (x:f64)
    (mul x 2)
)
```

在 XiaoXuan Lang IR 里，用户自定义函数可以赋值给另外一个标识符，也可以作为参数传给另外一个函数，比如：

```clojure
;; 定义一个名为 `apply` 的用户自定义函数，函数有两个参数，
;; 第一个参数用于传入一个函数，第二个参数用于传入一个操作数。
;; 函数的主体是使用传入的函数应用到操作数，并返回结果。
(defn apply
    (func num)
    (func num 2)
)

(apply add 10) ;; 将 add 函数传入 apply 函数，返回结果 12
(apply mul 10) ;; 将 mul 函数传入 apply 函数，返回结果 20
```

注：XiaoXuan Lang IR 不支持类似常见编程语言当中的 `return` 语句，即无法中途返回一个值，但使用条件控制结构可以实现相同的目的。

### 递归调用的函数

如果要构建一个需要递归调用的用户自定义函数，可以使用 `defnr` 表达式。使用 `defnr` 表达式构建的函数会进行尾部调用优化（Tail call optimization），以防止运行时创建过多的调用栈。

`defnr` 表达式跟 `loop` 表达式非常相似，详细规则见 [循环控制表达式](#循环控制表达式)

示例：

```clojure
(defnr sum (current end acc)
    (if (gt current end)
        (break acc)
        (do
            (let next (add current 1))
            (let sum (add acc current))
            (recur next end sum)
        )
    )
)
```

上面的示例演示了一个从整数 `start` 累加到 `end` 的程序，比如 `(sum 1 100 0)` 会返回 `5050`。

### 匿名函数

匿名函数即在用户自定义函数里定义的函数，有些编程语言也称为 `Lambda`，跟用户自定义函数一样，匿名函数可以赋值到一个变量，也可以可以作为参数传给另外一个函数。不同的是，匿名函数还会捕获其所在环境（Environment）的标识符的值，并有自己的环境。

匿名函数使用 `fn` 表达式定义，`fn` 表达式格式如下。

```clojure
(fn (param1 param2 ... paramN)
    (primitive_identifier1 primitive_identifier2 ... primitive_identifierN)
    (udt_identifier1 udt_identifier2 ... udt_identifierN)
    function_body
)
```

`fn` 表达式的第一个子表达式是参数列表；第二个子表达式是需捕获的基本数据类型的标识符的名称列表，如果没有则留空；第三个子表达式是需捕获的用户自定义数据类型的标识符的名称列表，如果没有则留空；最后一个子表达式是匿名函数的主体。

示例：

```clojure
(defn inc (level)
    (fn (num)
        (level)
        ()
        (add level num)
    )
)
```

上面示例代码定义了一个名为 `inc` 的用户自定义函数，调用它后会传回一个匿名函数，该匿名函数捕获了环境标识符 `level`，所以 `fn` 表达式的第二个表达式是 `(level)`。应用示例：

```clojure
(do
    (let incTwo (inc 2))
    (let incTen (inc 10))
    (incTwo 2) ;; 返回 2+2=4
    (incTwo 6) ;; 返回 2+6=8
    (incTen 2) ;; 返回 10+2=12
    (incTen 6) ;; 返回 10+6=16
)
```

之所以需要将基本类型的标识符和用户自定义数据类型的标识符分别列出，是因为基本类型标识符的值只需简单复制到匿名函数自己的环境，而用户自定义数据类型的标识符，则在捕获时需要增加其引用计数值。并且需要绑定了匿名函数的标识符超出作用域时减少它们的引用计数值。详细请见 [用户自定义数据及内存管理](user-defined-data-and-memory-management.md)。

## 注释

XiaoXuan Lang IR 支持单行注释，以分号 `;` 开始，直到句尾。注释的内容会被编译器忽略。

示例：

```clojure
; 这是一行注释
(let i 123) ; 从这里开始一直到行尾都是注释
```

## 标注

在表达式开始符号 `(` 前面添加 `@` 符号表示给该表达式添加标注，这些标注一般是给编译器使用的，比如标注 XiaoXuan Lang IR 代码对应的 XiaoXuan Lang 源码的位置信息等，示例：

```clojure
(namespace foo
    @source_map:line=12,column=4(defn test () (...))
)
```

## 语言约束

XiaoXuan Lang IR 有一些语言级别的约束，如果没有满足这些约束，编译器会拒绝编译：

1. 前面章节已讲述的约束，比如：`loop` 表达式的最后一句必须是 `break` 或者 `recur`；标识符不能名称冲突等。

2. `if` 表达式里的 3 个子表达式均不能直接写 `let` 表达式，如果需要创建局部变量，可以构建一个 `do` 表达式，然后在里面写 `let` 表达式。详细见 [条件表达式的作用域](#条件表达式的作用域)。

3. 函数的参数不能直接传入 `::new(...)` 以及 `::new$N(...)` 之类的对象构造函数，需要使用 `let` 表达式接收此类构造函数生成的对象，然后再把它作为值传递给其他函数。对于前端语言里直接在参数里传入新构造对象的语句，可以解析为使用 `do` 把调用函数的语句包围起来。比如：

```clojure
(do
    (let a (x::new ...))
    (let b (y::new ...))
    (func a b)
)
```

4. 匿名函数不能在定义的同时直接调用，需要使用 `let` 表达式接收其值，然后再调用它或者把它作为值传递给其他函数。

上面的后 3 条约束皆与 XiaoXuan Lang IR 的资源回收工作方式有关，详细请见 [用户自定义数据及内存管理](user-defined-data-and-memory-management.md)。