# 表达式

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [表达式](#表达式)
  - [基本数据类型](#基本数据类型)
  - [基本语法](#基本语法)
  - [赋值表达式](#赋值表达式)
    - [值的不变性](#值的不变性)
    - [值的复制](#值的复制)
  - [常量表达式](#常量表达式)
    - [值的替换](#值的替换)
  - [命名空间表达式](#命名空间表达式)
    - [层次型命名空间](#层次型命名空间)
    - [命名空间路径](#命名空间路径)
    - [根命名空间](#根命名空间)
    - [访问其他模块里的标识符](#访问其他模块里的标识符)
    - [访问同一个模块里的标识符](#访问同一个模块里的标识符)
    - [名称冲突](#名称冲突)
  - [块表达式](#块表达式)
  - [注释](#注释)

<!-- /code_chunk_output -->

## 基本数据类型

XiaoXuan IR 只支持 `i32`, `i64`, `f32` 和 `f64` 四种基本数据类型（primitive data type）。在 XiaoXuan IR 源码里可以使用数字字面量表示这 4 种数据类型，如果数字字面量的格式是 `[\+\-]?[0-9]+`，则会被解析为整型，如果数字字面量还包含有小数点或者字符 `e` 则会解析为浮点型，默认整型是 `i64`，默认浮点型是 `f64`。示例：

* i64: `123`, `-1`, `0`, `-456`
* f64: `2.718`, `6.626e-34`，`-1.23`，`3.0`

如果要表示 `i32` 和 `f32`，需要在字面量后面加上 `s` 字符后缀，示例：

* i32: `123s`，`-456s`
* f32: `3.14s`, `-4.56s`, `4.0s`

XiaoXuan IR 还支持名为 `int` 的数据类型，它是 `i32` 或者 `i64` 的别名，编译器会根据目标机器环境自动转换，`int` 类型常常用来表示内存地址、函数索引、结构体（用户自定义类型）索引、结构体成员的索引。

## 基本语法

XiaoXuan IR 源码由 [S-表达式](https://en.wikipedia.org/wiki/S-expression) 组成，表达式由一对圆括号里面填上由空格分开的函数名称及参数组成。

语法：

`(function-name arg1 arg2 ... argN)`

每个表达式可视作一次函数调用，其中 `function-name` 是函数名称，`arg1`、`arg2` 和 `argN` 是参数，每个表达式 "必须" 有返回值，对于无意义返回值的表达值，约定返回整数（即 int 类型） `0`。

表达式可以嵌套，示例：

```clojure
(root (add (square 3) (square 4)))
```

上面代码相当于函数：

\[
    \sqrt{3^2 + 4^2}
\]

运行时，表达式会依次从最外层开始求值（"求值" 也就是调用函数并获取其返回值），但遇到参数是另外一个表达式时，需要先内层表达式求值才能作为参数值对外层表达式求值，所以实际上最内层的表达式会最先被执行。

一个源文件可以有一个或多个表达式，也就是说一个程序本质是一系列函数的调用。

表达式可以大致分为 3 类：

* 内置函数
  内置函数对应着机器指令或者机器指令的简单组合，如整数相加、位运算 "或" 等。
* 用户自定义函数
  实现一定功能的代码块，一般是将内置函数、组织表达式以及其他自定义函数按照逻辑组合在一起而形成。
* 基本表达式
  用于组织源码的表达式，比如赋值表达式、条件表达式，基本表达式相当于一般高级语言的 "关键字"。

## 赋值表达式

赋值表达式用于创建一个在当前环境（Environment）之内的变量（局部变量），或者说，将一个值绑定到一个`标识符`（identifier）。

语法：

`(let variable-name value)`

其中第 2 个参数是值参数，值参数可以是 IR 支持的基本数据类型的字面量，示例：

```clojure
(let i 123)
(let j 3.14s)
```

值参数也可以是另一个表达式，示例：

```clojure
(let i (let j 123))
```

因为赋值表达式的值（即表达式求值后返回的值）就是表达式内的值，所以上面示例的表达式先创建了一个名称为 `j` 的变量，其值为 `i64` 类型的 `123`，然后又创建了一个名称为 `i` 的变量，其值为里面表达式求值后返回的值————即 `i64` 类型的 `123`，最后表达式返回值 `i64` 类型的 `123`。

赋值表达式里的值参数还可以是一个函数，后面会详细讲述。

因为所有表达式返回值的数据类型，以及字面量的数据类型都是确定的，所以赋值表达式并不需要指定标识符的数据类型，编译器会自动推断。当然也可以显式指定标识符的数据类型，方法是在标识符后面加一个冒号 `:` 然后加上数据类型的名称，示例：

```clojure
(let i:i32 123)
```

### 值的不变性

标识符一旦创建（在创建的同时被赋值）之后，其值就不能再改变。XiaoXuan IR 没有提供可以更改标识符值的方法。

### 值的复制

一个标识符也可以赋值给另外一个标识符，示例：

```clojure
(let i 123)
(let j i)
```

* 如果标识符的值为基本数据类型，则值会被直接复制；
* 如果标识符的值为用户自定义函数，标识符的值实际上是函数的指针，所以标识符的值也是直接被复制。
* 如果标识符的值为用户自定义类型，因为所有用户自定义类型的数据都存储在堆里（相当于其他语言的引用类型变量），标识符的值实际上是数值的指针（即数据在内存的地址），所以在复制标识符的值时，还会同时增加目标数据的引用计数值，当程序执行到标识符的作用范围之外时，目标数据的引用计数值会相应地减少。

## 常量表达式

常量表达式和赋值表达式非常类似，都是用于将一个值绑定到一个标识符里，区别是赋值表达式只能在函数里使用，常量表达式只能在名称空间里使用。

常量表达式语法如下：

`(const variable-name value)`

示例：

```clojure
(const PI 3.14)
(const E 2.718)
```

### 值的替换

常量表达式创建的标识符跟赋值表达式创建的还有另一个区别：常量的值是在编译时就确定的，另外在编译是还会对所有引用常量的地方作预处理：

* 如果常量的值为基本数据类型的字面量，则在编译时，代码中所有引用该常量的地方会自动替换成相应的字面量。
* 如果常量的值为用户自定义函数，常量的值实际上是函数的指针，则在编译时，代码中所有引用该常量的地方会自动替换成相应的值。
* 如果常量的值为用户自定义类型，情况跟赋值表达式类似，但在编译时该自定义类型数据的值事先构建并存储在数据段里，常量的值实际上是该数据在内存的指针，代码中所有引用该常量的地方会自动替换成相应的值。

被标为常量的数据的引用计数值不会改变，所以常量数据不会被资源回收。

## 命名空间表达式

XiaoXuan IR 程序是一种编译过程当中的中间代码，本质上是对机器指令的简单封装。具体来说，IR 程序就是由一堆平行的（用户自定义）函数组成的代码。

当一个程序规模较大时，所有函数堆在一起会显得难以维护，所以 XiaoXuan IR 使用一个叫做 `命名空间`（`namespace`）的概念将函数按照相关性划分为一个一个的 "小组"，每个 "小组" 就称为一个命名空间。每个命名空间里会有一个或多个用户自定义函数表达式，还有一个或多个常量表达式，除此之外再也没有其他东西。

示例：

```clojure
(namespace foo
    (const PI 3.14)
    (defn inc (i) (add i 1))
    (defn dec (i) (sub i 1))
)
```

上面代码当中的 `foo` 是命名空间的名称，里面的 3 个表达式分别表示定义了一个常量及两个函数。

在一个模块（在一般编程语言里也叫做 `包`，`package`）里，一个命名空间的代码不必一次过全部写完，可以分布到多个同名的 `namespace` 之内，甚至可以分布到多个文件之内，只要名称相同，编译器就会把它们合并成同一个命名空间。示例：

```clojure
(namespace foo
    (const PI 3.14)
)

(namespace foo
    (defn inc (i) (add i 1))
    (defn dec (i) (sub i 1))
)
```

上面的代码在编译时会被分别编译，但最后会作为同一个命名空间 `foo`，其结果是跟上一个例子的代码是完全一样的。不过在不同的模块里，即使命名空间名称相同，也是不同的命名空间，后面会详细讲述。

在运行时，每个命名空间都有（且只有）一个环境对象（Environment，可以想象为一个散列 Map），用户自定义函数及常量以平铺的形式存储在命名空间对应的环境对象里。上面的示例代码所构造的环境对象如果是用 JavaScript 对象来表示的话，大致如下：

```js
{
    "PI": 3.14,
    "inc": Function(...),
    "dec:" Function(...)
}
```

### 层次型命名空间

在给一个命名空间命名时，可以为它加上其他命名空间的名称作为前缀，以表示当前命名空间是目标命名空间领域之下的一个细分。名称和名称之间使用点号 `.` 分隔。

示例：

```clojure
(namespace foo
    (const A 123)
)

(namespace foo.bar
    (const B 456)
)

(namespace foo.bar.one
    (const C 789)
)
```

上面的代码构建了三个命名空间 `foo`、`bar` 和 `one`。

使用多层命名空间可以将相关功能更细化地分组，但需要注意虽然命名空间在名称上存在层次关系（或者说：父子关系），但实际上每个命名空间都是同级的、平行的、相互独立的。在运行时，子命名空间的环境并不会继承父命名空间的环境的任何标识符，不同的命名空间的标识符都没任何联系。

### 命名空间路径

通过连接符号————点号 `.` 将存在层次关系的各个命名空间的名称连接起来的字符串称为命名空间的 `命名空间路径`，比如上一个示例的 3 个命名空间的路径分别是：

* `foo`
* `foo.bar`
* `foo.bar.one`

### 根命名空间

路径的最前面还隐藏着一个命名空间，即第一个命名空间，称为 `根命名空间`。根命名空间的名字就是当前模块的名称。

完整的命名空间路径应该包含根命名空间的名称，假如上例当中所在的模块名称为 `mylib`，则 3 个命名空间的完整路径应该是：

* `mylib.foo`
* `mylib.foo.bar`
* `mylib.foo.bar.one`

标识符的完整名称就是：标识符所在的命名空间的路径 + 标识符的名称。

比如上例当中的常量 `A`，`B` 和 `C` 的完整名称是：

* `mylib.foo.A`
* `mylib.foo.bar.B`
* `mylib.foo.bar.one.C`

如果想把标识符定义在根命名空间里，则需要传参数 `()` （即一对空括号） 给 `namespace` 表达式的第一个参数，比如在上例的代码末尾加上如下代码：

```clojure
(namespace ()
    (const X 100)
)
```

则常量 `X` 被定义在根命名空间里，这个常量的完整路径为 `mylib.A`。

### 访问其他模块里的标识符

在一个模块里想访问另一个模块的标识符，需要把这个标识符的完整路径写出来。比如现在有一个叫做 `example` 模块，想访问上例当中的常量 `B`，则代码如下：

```clojure
(namespace ()
    (defn main () (do
        (let i mylib.foo.B)
    ))
)
```

上面的代码当中的 `mylib.foo.B` 表示访问 `mylib` 模块的命名空间 `foo` 之内的常量 `B`。

有时一个标识符可能会被多次引用，重复书写完整路径会稍显啰嗦，这时可以使用 `use` 表达式将目标标识符加载到当前命名空间的代码范围之内，示例：

```clojure
(namespace ()
    (use mylib.foo.B)
    (defn main () (do
        (let i B)
    ))
)
```

上面的 `use` 表达式将 `mylib.foo.B` 引入到当前命名空间的代码范围，在解析这段命名空间的代码时，所有出现标识符 `B` 都会被解析（或者说被替换）为 `mylib.foo.B`。一般来说，机器生成的 IR 代码总是写标识符全称的（毕竟 IR 并不是设计给人直接阅读），使用 `use` 表达式的目的主要是便于调试 IR 程序时手动修改程序的工作。

需注意的是，使用 `use` 表达式引入的标识符仅在当前 `namespace` 的源码范围内有效，不能覆盖不同的命名空间，也不能覆盖同名但不是同一个 `namespace` 表达式的范围。

### 访问同一个模块里的标识符

在同一个模块的同一个命名空间里，访问标识符只需单独书写标识符的名称即可，比如：

```clojure
(namespce foo
    (const A 1)
    (defn inc (i) (add A i))
    (defn incAndDouble (i) (mul (inc i) 2))
)
```

在上面的代码中，函数 `inc` 引用常量 `A`，只需直接书写常量的名称即可；同样函数 `incAndDouble` 引用了函数 `inc` 只需直接书写函数名称即可。

在同一个模块里，访问不同的命名空间里的标识符需要写上标识符的完整名称，这是因为正如前面所说，不同命名空间虽然在名称上有层次关系，但实际上是相互独立的。

假设当前模块的名称为 `mylib`，上面代码创建了一个命名空间 `foo`，现在有另外一个命名空间 `foo.bar`，如果想访问 `foo` 命名空间里面的常量 `A`，则代码如下：

```clojure
(namespace foo.bar
    (defn hello () (
        (let i mylib.foo.A))
    ))
)
```

为了方便访问同一个模块里不同命名空间里的标识符，XiaoXuan IR 规定在命名空间路径里有几个特殊的名称：

* `module` 用于代表当前模块的名称，有时模块名称可能比较长，或者在开发过程中会改变，使用当前模块名称的 `代号` 显然比起实际名称更容易维护。
* `parent` 用于代表当前模块的父命名空间，通过 `parent` 就可以使用 "相对路径" 来访问父命名空间，当命名空间路径比较长时，使用相对路径要比绝对路径更容易维护。
* `current` 用于表示当前命名空间，通过 `current` 就可以使用 "相对路径" 来访问子命名空间。

这 3 个特殊名称是 XiaoXuan IR 保留的名称，任何模块、命名空间都不能跟它们同名。

### 名称冲突

XiaoXuan IR 禁止以下几种情况，以防止名称冲突：

1. 在同一个命名空间里，不能定义同名的标识符常量或者函数。

示例：

```clojure
(namespace foo
    (const A 123)
    (defn A (i) (add i 2)) ;; 函数名称 `A` 跟常量 `A` 冲突
)
```

2. 在表达式里，在标识符的有效范围内（也叫做 `作用域`）不能定义同名的变量。

示例：

```clojure
(namespace foo
    (const A 123)
    (defn test (i) (do
        (let A 10) ;; 变量 `A` 名称跟常量 `A` 冲突
        (add A i)
    ))
)

(namespace foo
    (defn test (j) (do ;; 函数名称 `test` 在同一个命名空间内已经定义，所以有冲突
        ...
    ))
)
```

在上例中，常量 `A` 的作用域是整个命名空间，所以在函数 `test` 里定义同名的变量 `A` 会造成冲突。

当然在不同作用域里，是可以定义同名变量的，比如不同的函数就有不同的作用域，即使在同一个函数内，使用 `do` 表达式也能创建一个独立的作用域，示例：

```clojure
(namespace foo
    (defn hello (i) (do
        (let num 10)
        (do
            (let count 2)
            ...
        )
        (do
            (let count 88) ;; 不会冲突
            ...
        )
    ))

    (defn world (i) (do
        (let num 20) ;; 不会冲突
        ...
    ))
)
```

上面代码的第 2 个变量 `count` 虽然跟它上面的 `count` 在同一个函数里，但分别属于不同的作用域（使用 `do` 表达式创建的作用域），所以不会造成名称冲突。同样道理，第 2 个变量 `num` 虽然跟函数 `hello` 里的 `num` 变量同名，但分别属于不同的函数，作用域不相同，所以不会造成名称冲突。

3. 在命名空间里不能定义跟直接子名称空间同名的标识符。

示例：

```clojure
(namespace foo
    (const bar 123)
)

(namespace foo.bar ;; 名称 `bar` 跟 `foo` 里面的常量 `bar` 冲突
    ...
)
```

4. 在当前命名空间的代码范围内，不能定义跟使用 `use` 引入的标识符名称相同的标识符。

示例：

```clojure
(namespace foo
    (use mylib.math.abs)
    (defn test (i) (do
        (let abs 123) ;; 变量名称 `abs` 跟引入的标识符 `mylib.math.abs` 名称冲突
        ...
    ))
)

(namespace foo
    (defn main () (do
        (let abs 456) ;; 不会冲突
    ))
)
```

上面示例当中，虽然第 1 个 `namespace` 引入了标识符 `abs`，但它不会跨 `namespace` 表达式覆盖，所以第 2 个 `namespace` 表达式里的函数 `main` 定义了变量 `abs` 不会有名称冲突。

## 块表达式



## 注释

单行注释，以 `;` 开始，直到句尾。
表达式文档注释，在表达式开始符号 `(` 前面添加井号 `#` 表示注释该表达式。这些注释是给编译器使用的，通常情况下是 IR 代码对应的 XiaoXuan Lang 源码的位置信息。