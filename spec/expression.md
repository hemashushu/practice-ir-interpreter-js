# 表达式

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [表达式](#表达式)
  - [基本数据类型](#基本数据类型)
  - [基本语法](#基本语法)
  - [赋值表达式](#赋值表达式)
    - [值的不变性](#值的不变性)
    - [值的复制](#值的复制)
  - [常量表达式](#常量表达式)
    - [值的替换](#值的替换)
  - [命名空间表达式](#命名空间表达式)
    - [层次型命名空间](#层次型命名空间)
    - [命名空间路径](#命名空间路径)
    - [根命名空间](#根命名空间)
    - [访问其他模块里的标识符](#访问其他模块里的标识符)
      - [`use` 表达式](#use-表达式)
    - [访问同一个模块里的标识符](#访问同一个模块里的标识符)
      - [特殊的命名空间名称和相对路径](#特殊的命名空间名称和相对路径)
    - [名称冲突](#名称冲突)
    - [默认名称空间](#默认名称空间)
  - [块表达式](#块表达式)
    - [作用域](#作用域)
  - [分支表达式](#分支表达式)
  - [循环表达式](#循环表达式)
  - [注释](#注释)
    - [单行注释](#单行注释)
    - [表达式注释](#表达式注释)
  - [标注](#标注)

<!-- /code_chunk_output -->

XiaoXuan Lang IR 是将 XiaoXuan Lang 程序编译成目标程序（本地代码或者字节码）过程中的中间代码，它是对目标机器指令的简单抽象和封装。

## 基本数据类型

XiaoXuan IR 只支持 `i32`, `i64`, `f32` 和 `f64` 四种基本数据类型（primitive data type）。在 XiaoXuan IR 源码里可以使用数字字面量表示这 4 种数据类型，如果数字字面量的格式是 `[\+\-]?[0-9]+`，则会被解析为整型，如果数字字面量还包含有小数点或者字符 `e` 则会解析为浮点型，默认整型是 `i64`，默认浮点型是 `f64`。示例：

* i64: `123`, `-1`, `0`, `-456`
* f64: `2.718`, `6.626e-34`，`-1.23`，`3.0`

如果要表示 `i32` 和 `f32`，需要在字面量后面加上 `s` 字符后缀，示例：

* i32: `123s`，`-456s`
* f32: `3.14s`, `-4.56s`, `4.0s`

XiaoXuan IR 还支持名为 `int` 的数据类型，它是 `i32` 或者 `i64` 的别名，编译器会根据目标机器环境自动转换，`int` 类型常常用来表示内存地址、函数索引、结构体（用户自定义类型）索引、结构体成员的索引。

## 基本语法

XiaoXuan IR 源码由 [S-表达式](https://en.wikipedia.org/wiki/S-expression) 组成，表达式由一对圆括号里面填上由空格分开的函数名称及参数组成。

语法：

`(function-name arg1 arg2 ... argN)`

每个表达式可视作一次函数调用，其中 `function-name` 是函数名称，`arg1`、`arg2` 和 `argN` 是参数，每个表达式 "必须" 有返回值，对于无意义返回值的表达值，约定返回整数（即 int 类型） `0`。

表达式可以嵌套，示例：

```clojure
(root (add (square 3) (square 4)))
```

上面代码相当于函数：

\[
    \sqrt{3^2 + 4^2}
\]

运行时，表达式会依次从最外层开始求值（"求值" 是指调用函数并获取其返回值），但遇到参数是另外一个表达式时，需要先内层表达式求值才能作为参数值对外层表达式求值，所以在编译时，最内层的表达式一般会最先编译成目标代码。

一个 IR 源文件可以有一个或多个表达式，也就是说一个程序本质是一系列函数的调用。

表达式可以大致分为 3 类：

* 内置函数
  内置函数对应着机器指令或者机器指令的简单组合，如整数相加、位运算 "或" 等。
* 用户自定义函数
  实现一定功能的代码块，一般是将内置函数、组织表达式以及其他自定义函数按照逻辑组合在一起而形成。
* 基本表达式
  用于组织源码的表达式，比如赋值表达式、条件表达式，基本表达式相当于一般高级语言的 "关键字"。

## 赋值表达式

赋值表达式（`let` 表达式）用于在当前环境（Environment）之内创建一个变量（局部变量）并赋值，或者说，将一个值绑定到一个`标识符`（identifier）。

语法：

`(let variable-name value)`

其中第 2 个参数 `value` 用于传入待绑定的值，值可以是 IR 支持的基本数据类型的字面量，示例：

```clojure
(let i 123)
(let j 3.14s)
```

值也可以是另一个表达式，示例：

```clojure
(let i (let j 123))
```

赋值表达式的值（即表达式求值后的返回值）就是表达式内的标识符的值，上面示例当中的表达式先创建了一个名称为 `j` 的变量，其值为 `i64` 类型的 `123`，然后又创建了一个名称为 `i` 的变量，其值为里面表达式求值后的返回值————即 `i64` 类型的 `123`，最后表达式返回 `i64` 类型的 `123`。

赋值表达式里的参数 `value` 还可以是一个函数，后面会讲述。

因为所有表达式返回值的数据类型以及字面量的数据类型都是确定的，所以并不需要指定标识符的数据类型，编译器会自动推断。

### 值的不变性

标识符一旦创建之后，其值就不能再改变。XiaoXuan IR 没有提供可以更改标识符值的方法。

### 值的复制

一个标识符也可以赋值给另外一个标识符，示例：

```clojure
(let i 123)
(let j i)
```

将一个标识符赋值给另外一个标识符实际上是对值进行复制，具体如下：

* 如果标识符的值为基本数据类型，则值会被直接复制；
* 如果标识符的值为用户自定义函数，标识符的值实际上是函数的指针，所以标识符的值也是直接被复制。
* 如果标识符的值为用户自定义类型，因为所有用户自定义类型的数据都存储在堆里（相当于其他语言的引用类型变量），标识符的值实际上是数据的指针（即数据在内存的地址），所以在复制此类标识符的值时，还会同时增加目标数据的引用计数值，当程序执行到标识符的作用范围之外时，目标数据的引用计数值会相应地减少。

## 常量表达式

常量表达式（`const` 表达式）和赋值表达式非常类似，都是用于将一个值绑定到一个标识符里，区别是：

* 赋值表达式只能在函数里使用，常量表达式只能在名称空间里使用；（此约束由编译器的语法检查阶段实现）
* 赋值表达式的值在运行过程中确定，常量表达式的值在编译时就已经确定。

常量表达式语法如下：

`(const variable-name value)`

示例：

```clojure
(const PI 3.14)
(const E 2.718)
```

### 值的替换

编译器在预处理阶段会对所有引用常量的地方作替换处理，具体如下：

* 如果常量的值为基本数据类型的字面量，则在编译时，代码中所有引用该常量的地方会自动替换成相应的字面量。
* 如果常量的值为用户自定义函数，常量的值实际上是函数的指针，则在编译时，代码中所有引用该常量的地方会自动替换成相应的值。
* 如果常量的值为用户自定义类型，情况跟赋值表达式类似，但在编译时该自定义类型数据的值事先构建并存储在数据段里，常量的值实际上是该数据在内存的指针，代码中所有引用该常量的地方会自动替换成相应的值。

被标为常量的数据的引用计数值不会改变，所以常量数据不会被资源回收。

## 命名空间表达式

XiaoXuan IR 程序由一堆平行的用户自定义函数和常量组成，当一个程序规模较大时，所有函数堆在一起会比较难维护，XiaoXuan IR 使用一个叫做 `命名空间`（`namespace`）的概念将函数按照相关性划分为一个一个的 "小组"，每个 "小组" 就称为一个命名空间。每个命名空间里会有零个或多个用户自定义函数表达式，以及零个或多个常量表达式。

示例：

```clojure
(namespace foo
    (const PI 3.14)
    (defn inc (i) (add i 1))
    (defn dec (i) (sub i 1))
)
```

上面代码当中的 `foo` 是命名空间的名称，里面的 3 个表达式分别表示定义了一个常量及两个函数。

在一个模块（在一般编程语言里也叫做 `包`，`package`）里，一个命名空间的代码不必一次过全部写完，可以分布到多个 `namespace` 表达式，甚至可以分布到多个文件之内，只要名称相同即可，编译器会把它们合并成同一个命名空间。示例：

```clojure
(namespace foo
    (const PI 3.14)
)

(namespace foo
    (defn inc (i) (add i 1))
    (defn dec (i) (sub i 1))
)
```

上面的代码在编译时会被分别编译，但最后会合并为同一个命名空间 `foo`，其结果是跟上一个例子的代码是完全等效的。不过如果模块不同，即使命名空间名称相同，也是不同的命名空间，后面会详细讲述。

在运行时，每个命名空间都有（且只有）一个环境对象（Environment，可以想象为一个散列 Map），用户自定义函数及常量以平铺的形式存储在里面。上面的示例代码所构造的环境对象如果是用 JavaScript 对象来表示的话，大致如下：

```js
{
    "PI": 3.14,
    "inc": Function(...),
    "dec:" Function(...)
}
```

`namespace` 表达式是用于组织代码的一个特殊表达式，其返回值由 XiaoXuan IR 的具体编译器或者解析器（interpreter）决定，比如对于解析器可能会返回类似上面那样的环境对象或者环境对象的指针，而对于目标为本地代码的编译器，编译之后可能根本不存在所谓的命名空间，所以这个表达式没有返回值。

### 层次型命名空间

在给一个命名空间命名时，可以为它加上其他命名空间的名称作为前缀，以表示当前命名空间是目标命名空间下面的一个细分。名称和名称之间使用点号 `.` 分隔。

示例：

```clojure
(namespace foo
    (const A 123)
)

(namespace foo.bar
    (const B 456)
)

(namespace foo.bar.one
    (const C 789)
)
```

上面的代码构建了三个命名空间 `foo`、`bar` 和 `one`。

使用多层命名空间可以将相关功能更细化地分组，但需要注意虽然命名空间在名称上存在层次关系（或者说：父子关系），但实际上每个命名空间都是同级的、平行的、相互独立的。在运行时，子命名空间的环境并不会继承父命名空间的环境的任何标识符，不同的命名空间的里面的标识符之间没有任何关联。

### 命名空间路径

通过连接符号————点号 `.` 将存在层次关系的各个命名空间的名称连接起来的字符串，称为 `命名空间路径`，比如上一个示例的 3 个命名空间的路径分别是：

* `foo`
* `foo.bar`
* `foo.bar.one`

### 根命名空间

命名空间路径的最前面还隐藏着一个命名空间，即第一个命名空间，称为 `根命名空间`。根命名空间的名字就是当前模块的名称。

完整的命名空间路径应该包含根命名空间的名称，假如上例当中所在的模块名称为 `mylib`，则 3 个命名空间的完整路径（Full namepath）是：

* `mylib.foo`
* `mylib.foo.bar`
* `mylib.foo.bar.one`

标识符的完整名称（Fullname）就是：标识符所在的命名空间的完整路径 + 标识符的名称。

比如上例当中的常量 `A`，`B` 和 `C` 的完整名称是：

* `mylib.foo.A`
* `mylib.foo.bar.B`
* `mylib.foo.bar.one.C`

如果想把标识符定义在一个模块的根命名空间里，则需要传参数 `()` （即一对空括号） 给 `namespace` 表达式的第一个参数，比如在上例的代码末尾加上如下代码：

```clojure
(namespace ()
    (const X 100)
)
```

则常量 `X` 被定义在根命名空间里，这个常量的完整名称为 `mylib.A`。

### 访问其他模块里的标识符

在一个模块里想访问另一个模块里的标识符，需要把这个标识符的完整名称写出来。比如现在有一个叫做 `example` 模块，想访问上例当中的常量 `B`，则代码如下：

```clojure
(namespace ()
    (defn main () (do
        (let i mylib.foo.B)
    ))
)
```

#### `use` 表达式

有时一个标识符可能会被多次引用，重复书写完整名称会稍显冗余，这时可以使用 `use` 表达式将目标标识符引入到当前命名空间表达式（`namespace` 表达式）的代码范围之内，示例：

```clojure
(namespace app
    (use mylib.foo.B)
    (defn main () (do
        (let i B)
    ))
)
```

上面的 `use` 表达式将标识符完整名称 `mylib.foo.B` 引入到当前命名空间表达式的代码范围之内，在编译这段命名空间表达式的代码之前的预处理阶段，所有出现标识符 `B` 的地方都会被替换为 `mylib.foo.B`。

需注意的是：

* `use` 表达式仅仅在源代码层次实现了标识符完整名称的简写的功能，而不像一些语言的 `use` 或者 `import` 语句那样，它们可能会从另外一个文件导入一个模块，在功能上比 XiaoXuan IR 的 `use` 表达式要复杂得多。
* 使用 `use` 表达式引入的标识符名称仅在当前 `namespace` 表达式的源码范围内有效，它不能覆盖到其他命名空间，甚至不能覆盖到同名命名空间表达式。
* 跟 `namespace` 表达式类似，`use` 表达式是一个用于组织代码的特殊表达式，它在编译之前的预处理阶段执行，在预处理之后不再存在，所以 `use` 表达式没有返回值。

一般来说，机器生成的 IR 代码总是写标识符全称的（毕竟 IR 并不是设计给人直接阅读），使用 `use` 表达式的主要目的是便于手写和调试 IR 程序。

### 访问同一个模块里的标识符

在同一个模块的同一个命名空间里，访问标识符只需单独书写标识符的名称即可，比如：

```clojure
(namespce foo
    (const A 1)
    (defn inc (i) (add A i))
    (defn incAndDouble (i) (mul (inc i) 2))
)
```

在上面的代码中，函数 `inc` 引用常量 `A`，只需直接书写这个常量的名称；同样在函数 `incAndDouble` 里引用了函数 `inc` 只需直接书写这个函数名称即可。

在同一个模块里，如果要访问不同的命名空间里的标识符，则需要写上标识符的完整名称，这是因为正如前面所说，不同命名空间虽然在名称上有层次关系，但实际上是相互独立的。

假设当前模块的名称为 `mylib`，上面代码创建了一个命名空间 `foo`，现在有另外一个命名空间 `foo.bar`，如果想访问 `foo` 命名空间里面的常量 `A`，则代码如下：

```clojure
(namespace foo.bar
    (defn hello () (
        (let i mylib.foo.A))
    ))
)
```

#### 特殊的命名空间名称和相对路径

为了方便访问同一个模块里不同命名空间里的标识符，XiaoXuan IR 规定在命名空间路径里的第一个名称有几个特殊的名称：

* `module` 用于代表当前模块的名称，有时模块名称可能比较长，或者在开发过程中会改变，使用当前模块名称的 "代号" 显然比起实际名称更容易维护，比如在模块 `mylib` 里，`module.math` 表示 `mylib.math`。
* `current` 用于表示当前命名空间，通过 `current` 就可以使用 "相对路径" 来访问子命名空间。当命名空间路径比较长时，使用相对路径要比绝对路径更容易书写。
* `parent` 用于代表当前模块的父命名空间，通过 `parent` 就可以使用 "相对路径" 来访问父命名空间，还可以通过叠加 `parent` 表示任意层的父命名空间，比如 `parent.parent` 表示上两层命名空间。

这 3 个特殊名称是 XiaoXuan IR 保留的名称，任何模块、命名空间都不能跟它们同名。

跟 `use` 表达式类似，这 3 个特殊名称会在编译之前的预处理阶段被替换成完整的路径，在编译之后这些特殊名称是不存在的。

### 名称冲突

XiaoXuan IR 禁止以下几种情况，以防止名称冲突：

1. 在同一个命名空间里，不能定义同名的标识符常量或者函数。

示例：

```clojure
(namespace foo
    (const A 123)
    (defn A (i) (add i 2)) ;; 函数 `A` 跟常量 `A` 名称冲突
)
```

2. 在表达式里，在标识符的有效范围内（即 `作用域`，下面会讲述）不能定义同名的变量。

示例：

```clojure
(namespace foo
    (const A 123)
    (defn test (i) (do
        (let A 10) ;; 变量 `A` 跟常量 `A` 名称冲突
        (add A i)
    ))
)

(namespace foo
    (defn test (j) (do ;; 函数 `test` 跟上一个函数 `test` 名称冲突
        ...
    ))
)
```

在上例中，常量 `A` 的作用域是整个命名空间，所以在函数 `test` 里定义同名的变量 `A` 会造成冲突。至于两个函数 `test`，虽然它们分布在不同的 `namespace` 表达式里，但名称空间是一样的，所以作用范围也是一样的，所以名称也会冲突。

3. 在命名空间里不能定义跟直接子名称空间同名的标识符。

示例：

```clojure
(namespace foo
    (const bar 123)
)

(namespace foo.bar ;; 命名空间 `bar` 跟命名空间 `foo` 里面的常量 `bar` 有名称冲突
    ...
)
```

4. 在同一个 `namespace` 表达式里，不能定义跟使用 `use` 引入的标识符名称相同的标识符。

示例：

```clojure
(namespace foo
    (use mylib.A)
    (const A 123) ;; 常量 `A` 跟引入的标识符 `mylib.A` 名称冲突
)

(namespace foo
    (const A 456) ;; 因为位于另一个 namespace 表达式，这里的常量 `A` 不会跟上面的标识符 `mylib.A` 名称冲突
)
```

### 默认名称空间

当程序以 REPL（Read–eval–print loop） 交互形式运行时，默认会在一个名为 `user` 的名称空间里，也就是说，当用户直接执行诸如常量表达式或者定义函数表达式时，这些创建的标识符会被挂靠在 `user` 名称空间里。对于 REPL 环境，一般还会提供额外的指令或者表达式，比如切换当前名称空间的指令，因为这些内容不属于 XiaoXuan Lang IR Spec 的范围，这里就不展开讲述了。

## 块表达式

使用块表达式（`do` 表达式）可以将多个表达式组成一个区块，在执行时，区块里的表达式依次被执行，最后那个表达式（或者标识符）的值会作为区块的值返回。

示例：

```clojure
(do
    (let a 10)
    (let b 20)
    (add a b)
)
```

上面代码创建了一个表达式块，里面有 3 个表达式，这 3 个表达式将会依次被执行。也就是依次定义了变量 `a` 和变量 `b`，然后执行表达式 `(add a b)` 将两个变量的值相加，最后相加的结果会作为表达式块的值返回。

因为最后一个表达式返回值的数据类型是确定的，所以块表达式不需要指定返回值的数据类型，编译器会自动推断。

### 作用域

块表达式同时还会创建一个独立的 `作用域`。作用域就是标识符的有效范围，作用域的结构可以是平行的，示例：

```clojure
(do
    ;; 作用域 A
)
(do
    ;; 作用域 B
)
```

在上面的示例代码中，两个 `do` 表达式创建了两个作用域 `作用域 A` 和 `作用域 B`，位于这两个作用域之内的标识符完全不相干。平行作用域起到了有效范围的 "隔离" 效果。

作用域也可以是层次型的，示例：

```clojure
(do
    ;; 作用域 A
    (do
        ;; 作用域 B
    )
    ;; 作用域 A
)
```

对于层次型的作用域，处于外层作用域的标识符的有效范围会覆盖到内层作用域，在上面的示例代码中，`作用域 A` 的有效范围会覆盖 `作用域 B`。也就是说在 `作用域 B` 里能直接访问 `作用域 A` 里的所有标识符。但反过来，在 `作用域 A` 里无法访问 `作用域 B` 里面的标识符。

在同一个作用域，或者在被覆盖的作用域里，不能定义同名的标识符；而在不同作用域里，可以定义同名变量，示例：

```clojure
(namespace foo
    (defn hello (i) (do
        (let num 10)
        (do
            (let num 20)   ;; 跟上一层作用域里的 `num` 冲突
            (let count 2)
            ...
        )
        (do
            (let count 3)  ;; 不会跟上一个作用域里的 `count` 冲突
            ...
        )
    ))
)
```

## 分支表达式

使用分支表达式（`if` 表达式）可以根据条件执行不同的分支，并返回该分支的值，分支表达式的语法如下：

`(if condition true_exp false_exp)`

分支表达式有 3 个参数，每个参数都可以是一个表达式、标识符或者字面量。

参数 `condition` 用于表示条件，其值只能是 `int` 类型的数字 `0` 或者 `-1`，其中 `0` 表示逻辑 `false`，数字 `-1` 表示逻辑 `true`。

当 `condition` 的值为 `-1` 时，执行并返回 `true_exp` 表达式，当 `condition` 的值为 `0` 时，执行并返回 `false_exp` 表达式。

示例：

```clojure
(do
    (let score 75)
    (if (gte score 60) 1 0)
)
```

上面的代码表示当变量 `score` 的值大于等于 `60` 时，返回 `1`，否则返回 `0`。

使用嵌套 `if` 表达式可以较复杂的逻辑，示例：

```clojure
(do
    (let score 80)
    (if (gte score 90)
        3
        (if (gte score 75)
            2
            (if (gte score 60) 1 0)
        )
    )
)
```

上面的代码演示里根据变量 `score` 的值所在的范围分别返回 `int` 数字 `3`、`2`、`1` 或 `0`。

## 循环表达式

使用循环表达式可以让目标表达式重复执行。循环表达式一共由 3 个子表达式完成，分别是：

1. `loop` 子表达式用于定义循环变量及其初始值；
2. `break` 子表达式用于中断循环并返回指定的值；
3. `recur` 子表达式用于更新循环变量的值并再次执行目标表达式。

其中 `loop` 子表达式的语法是：

`(loop (param1 param2 ...) (init_value1 init_value2 ...) target_exp)`

其中第一个参数是循环变量列表（所谓 `循环变量` 是指在每次循环里，其值有可能不同的同名标识符，相当于函数的形参），第二个参数是循环变量的初始值，第三个参数是被执行的目标表达式。

目标表达式最后需要返回一个列表:

* 如果返回的列表有两个元素，其中第一个元素的值为 `int` 数字 `0`，比如 `(0 123)`，则表示中止循环，并把第二个元素 `123` 作为整个循环表达式的值。
* 如果返回的列表有一个或多个元素，其中第一个元素的值为 `int` 数字 `-1`，比如 `(-1 77 88)`，则表示用第一个元素之外的元素重新带入 `loop` 子表达式的循环变量，然后再执行一次目标表达式。

在语法上，XiaoXuan IR 约定必须使用 `break` 或者 `recur` 子表达式构造目标表达式的返回值，实际上 `(break 123)` 就是返回 `(0 123)`，而 `(recur 77 88)` 就是返回列表 `(-1 77 88)`。

需注意：

* `break` 和 `recur` 子表达式必须位于目标表达式的最后一句；
* 如果目标表达式里面包含有分支，则必须保证每个分支的最后一句必须是 `break` 或者 `recur` 子表达式。

示例：

```clojure
(loop (count current) (10 1)
    (if (gt current count)
        (break count)
        (recur (add count current) (add current 1))
    )
)
```

上面示例代码实现了让 `current` 变量从数字 `1` 增长到 `11`，变量 `count` 每次循环都加上变量 `current` 的值，直到第 10 次之后中止循环。即程序实现了 \(1 + 2 + 3 + .. + 10 = 55\)，最后返回变量 `count` 的值，即数字 `55`。

需注意的是，使用 `recur` 更新循环变量的值并不是直接改变了变量本身的值，正如前面提到，XiaoXuan IR 所有变量的值都是不可改变的，所以它其实是使用新的值创建了一个新的循环变量，只是沿用了之前的名称而已。情况跟使用不同的值作为实参多次调用同一个函数类似，在函数内部，每次被调用其形参其实都指向不同的值。

## 注释

虽然 IR 主要被编译器作为中间代码使用，但为了便于教学以及手动调试之目的，所以仍然支持注释。注释有两种：

### 单行注释

以双分号 `;;` 开始，直到句尾。

示例：

```clojure
;; 这是一行注释
(let i 123) ;; 从这里开始一直到行尾都是注释
```

注释的内容会被编译器忽略。

### 表达式注释

在表达式开始符号 `(` 前面添加井号 `#` 表示注释该表达式。所以如果表达式里面有子表达式，则这个表达式连同所有位于内部的子表达式都会被编译器忽略。

示例：

```clojure
;; 注释单一的无嵌套的表达式
#(let i 123)

;; 注释有嵌套的表达式
#(do
    (let a 123)
    (let b 456)
    (add a b)
)
;; 整个 do 表达式（包括里面的 3 个内部表达式）都会被编译器忽略
```

## 标注

在表达式开始符号 `(` 前面添加 `@` 符号表示给该表达式添加标注，这些标注一般是给编译器使用的，比如标注 IR 代码对应的 XiaoXuan Lang 源码的位置信息等，示例：

```clojure
(namespace foo
    @source_map:line=12,column=4(defn test () (...))
)
```
